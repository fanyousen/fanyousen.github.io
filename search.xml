<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Statement</title>
    <url>/2019/06/01/Statement/</url>
    <content><![CDATA[<p>考研复习中，暂时不会更新博客。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机专业如何写软件设计类本科毕业论文</title>
    <url>/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%A6%82%E4%BD%95%E5%86%99%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%B1%BB%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>常用数据校验方法</title>
    <url>/2019/06/19/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1-数据校验"><a href="#1-1-数据校验" class="headerlink" title="1.1. 数据校验"></a>1.1. 数据校验</h2><p><a href="https://baike.baidu.com/item/数据校验" target="_blank" rel="noopener">数据校验百度百科</a></p>
<blockquote>
<p>《圣经》中的《旧约》部分是犹太人记载的自创世纪以来，主要是摩西以来他们祖先的历史。《圣经》和中国《史记》这本由唯一作者写成的史书不同，《圣经》的写作持续了很多世纪，后世的人在做补充时，看到的是几百年前甚至是上千年前原作的抄本。抄写的错误便在所难免。据说今天也只有牛津大学保留了一本没有任何错误的古本。虽然做事认真的犹太人要求在抄写《圣经》时，要虔诚并且打起十二分精神，尤其是每写到“上帝”（God 和 Lord）这个词时要去洗手祈祷，不过抄写错误还是难以避免。于是犹太人发明了一种类似于我们今天计算机和通信中校验码的方法。他们把每一个希伯来字母对应于一个数字，这样每行文字加起来便得到一个特殊的数字，这个数字便成了这一行的校验码。同样对于每一列也是这样处理。当犹太学者抄完一页《圣经》时，他们需要把每一行的文字加起来，看看新的校验码是否和原文的相同，然后对每一页进行同样的处理。如果这一页每一行和每一列的校验码和原文完全相同，说明这一页的手抄无误。如果某行的校验码和原文中的对不上，则说明这一行至少有一个抄写错误。当然，错误对应列的校验码也一定和原文对不上，这样可以很快找到出错的地方。这背后的原理和我们今天的各种校验码时相同的。</p>
</blockquote>
<p>上面是吴军《数学之美》一书中关于数据校验的一个例子，可见古代就已经有了对数据进行校验的方法。</p>
<p>在计算机和通信系统中，数据（二进制编码）在传输、存取过程中，会受到各种干扰的影响，使数据产生差错（如0变成1或1变成0）。为了能够发现及纠正传输过程中的差错，就在原始数据中增加冗余的编码，使其具有发现错误或纠错的功能。</p>
<h1 id="2-常见校验方式"><a href="#2-常见校验方式" class="headerlink" title="2. 常见校验方式"></a>2. 常见校验方式</h1><h2 id="2-1-奇偶校验"><a href="#2-1-奇偶校验" class="headerlink" title="2.1. 奇偶校验"></a>2.1. 奇偶校验</h2><p>奇偶校验(Parity Check)是一种非常简单的数据校验方法，使用非常广泛。</p>
<p>奇偶校验分为奇校验和偶校验</p>
<p><strong>对于偶校验</strong>，如果一组给定数据位中1的个数是奇数，在校验位补一个bit为1使得1的总个数为偶数。若1的个数已经是偶数，则在校验位补一个bit为0<br>例如：<br>&emsp;&emsp;0000 001，1的个数为奇数，补一个bit为1，即 0000 001<u>1</u><br>&emsp;&emsp;0000 011，1的个数为偶数，补一个bit为0，即 0000 011<u>0</u></p>
<p><strong>对于奇校验</strong>，如果一组给定数据位中1的个数是偶数，在校验位补一个bit为1使得1的总个数为奇数。若1的个数已经是奇数，则在校验位补一个bit为0<br>例如：<br>&emsp;&emsp;0000 001，1的个数为奇数，补一个bit为0，即 0000 001<u>0</u><br>&emsp;&emsp;0000 011，1的个数为偶数，补一个bit为1，即 0000 011<u>1</u></p>
<p>奇偶校验的错误检测：</p>
<p>如果传输过程中包括校验位在内的 奇数个数据位发生改变，那么数据的1的个数的奇偶性发生改变，从而可以发现数据出现错误（因为任何一个奇数或偶数加上一个奇数后，该数的奇偶性一定会发生改变）。因此，奇偶校验位是一种错误检测码，但是由于没有办法确定哪一位出错，所以它不能进行错误校正。发生错误时必须扔掉全部的数据，然后从头开始传输数据。</p>
<p>由上显然可以看出，当偶数个数据位发生改变时，使用奇偶校验方法并不能检测出数据出错。</p>
<h2 id="2-2-循环冗余校验"><a href="#2-2-循环冗余校验" class="headerlink" title="2.2. 循环冗余校验"></a>2.2. 循环冗余校验</h2><p>CRC即循环冗余校验码，是数据通信领域中最常用的一种查错校验码，其特征是信息字段和检验字段的长度可以任意选定。循环冗余检查是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在数据的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>
<h3 id="2-2-1-CRC码的生成"><a href="#2-2-1-CRC码的生成" class="headerlink" title="2.2.1. CRC码的生成"></a>2.2.1. CRC码的生成</h3><p>设CRC码共$n$位，信息字段$k$位<br>生成多项式为$P(X)=X^3+X^2+1$，则除数$P=1101$，则余数位数为$r=3$<br>信息为$D=1010 01$<br>首先将$D$左移$n-k=r=3$位，得到$\acute{D} =1010 0100 0$<br>再用$\acute{D}$除以$P$（使用模2除法）得到余数$R=001$<br>则CRC码为$\acute{D} +R = 1010 0100 1$</p>
<h3 id="CRC码的校验"><a href="#CRC码的校验" class="headerlink" title="CRC码的校验"></a>CRC码的校验</h3><p>将接收到的CRC码除以除数$P$，得到余数$R$<br>若$R=0$，则表示数据没有错误<br>若$R=1$，则表示数据出错</p>
<h2 id="2-3-汉明码"><a href="#2-3-汉明码" class="headerlink" title="2.3. 汉明码"></a>2.3. 汉明码</h2><h3 id="2-3-1-汉明码的组成"><a href="#2-3-1-汉明码的组成" class="headerlink" title="2.3.1. 汉明码的组成"></a>2.3.1. 汉明码的组成</h3><p>汉明码（也称为海明码）是由Richard Hanming于1950年提出的，它具有以为纠错能力。<br>由编码纠错理论知，任何一种编码是否具有检测能力和纠错能力，都与编码的最小距离有关。编码最小距离，是指在一种编码系统中，任意两组合法代码之间的最少二进制位的差异。</p>
<p>1011101与1001001之间的汉明距离是2<br>2143896与2233796之间的汉明距离是3<br>“toned”与”roses”之间的汉明距离是3<br>汉明距离即码距</p>
<p>根据纠错理论得：</p>
<script type="math/tex; mode=display">
L-1=D+C \quad 且D\geq C</script><p>即编码最小距离$L$越大，则其检测错误得位数$D$越大，纠正错误的位数$C$也越大，且纠错能力恒小于或等于检错能力。例如当最小距离$L=3$时，这种编码可视为最多能检错二位，或能检错一位、纠错一位。可见，若能在信息编码中增加若干位检测位，增大$L$，显然能提高检错和纠错能力。汉明码就是根据这一理论提出的具有一位纠错能力的编码。</p>
<p>设预检测得二进制代码位$n$位，为使其具有纠错能力，需增添$k$位检测位，组成$n+k$位得代码。为了能准确对错误定位以及指出代码没错，新增添的检测位数$k$应满足：</p>
<script type="math/tex; mode=display">
2^k \geq n+k+1</script><p>由此关系可求得不同代码长度$n$所需检测位的位数$k$，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$n$</th>
<th style="text-align:center">$k(最小)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2~4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">5~11</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">12~36</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p>$k$的位数确定后，便可由它们所承担的检测任务设定它们在被传送代码中的位置及它们的取值。<br>设$n+k$位代码自左至右一次编号为$1,2,3,…,n+k$位，而将$k$位检测位记作$C_i(i=2,4,8,…)$，分别安插在$n+k$位代码编号的第$1,2,4,8,…,2^{k-1}$位上。这些检测位的设置是为了保证它们能分别承担$n+k$位信息中不同数位所组成的“小组”的奇偶校验任务，使检测位和它所负责检测的小组中$1$的个数位奇数或位偶数，具体分配如下：</p>
<p>$C_1 检测的g_1小组包含1,3,5,7,9,11,…$位<br>$C_2 检测的g_2小组包含2,3,6,7,10,11,14,15,…$位<br>$C_4 检测的g_3小组包含4,5,6,7,12,13,14,15,…$位<br>$C_8 检测的g_4小组包含8,9,10,11,12,13,14,15,24…$位<br>…</p>
<p>将$C_1$的检测位$1,3,5,7,9,11,…$转换成二进制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">0011</td>
<td style="text-align:center">0101</td>
<td style="text-align:center">0111</td>
<td style="text-align:center">1001</td>
<td style="text-align:center">1011</td>
</tr>
<tr>
<td style="text-align:center">xxx1</td>
<td style="text-align:center">xxx1</td>
<td style="text-align:center">xxx1</td>
<td style="text-align:center">xxx1</td>
<td style="text-align:center">xxx1</td>
<td style="text-align:center">xxx1</td>
</tr>
</tbody>
</table>
</div>
<p>将$C_2$的检测位$2,3,6,7,10,11,14,15,…$转换成二进制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">0011</td>
<td style="text-align:center">0110</td>
<td style="text-align:center">0111</td>
<td style="text-align:center">1010</td>
<td style="text-align:center">1011</td>
<td style="text-align:center">1110</td>
<td style="text-align:center">1111</td>
</tr>
<tr>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
<td style="text-align:center">xx1x</td>
</tr>
</tbody>
</table>
</div>
<p>将$C_4$的检测位$4,5,6,7,12,13,14,15,…$转换成二进制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‭0100‬‬</td>
<td style="text-align:center">‭‭0101‬</td>
<td style="text-align:center">‭0110‬</td>
<td style="text-align:center">‭0111‬</td>
<td style="text-align:center">‭1100‬</td>
<td style="text-align:center">‭1101‬</td>
<td style="text-align:center">‭1110‬</td>
<td style="text-align:center">‭1111‬</td>
</tr>
<tr>
<td style="text-align:center">‭x1xx</td>
<td style="text-align:center">‭‭x1xx</td>
<td style="text-align:center">‭x1xx</td>
<td style="text-align:center">‭x1xx‬</td>
<td style="text-align:center">‭x1xx</td>
<td style="text-align:center">‭x1xx</td>
<td style="text-align:center">‭x1xx</td>
<td style="text-align:center">‭x1xx‬</td>
</tr>
</tbody>
</table>
</div>
<p>将$C_8$的检测位$8,9,10,11,12,13,14,15,24…$转换成二进制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">24</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">‭1001‬</td>
<td style="text-align:center">‭1010‬</td>
<td style="text-align:center">1011</td>
<td style="text-align:center">‭1100‬</td>
<td style="text-align:center">‭1101‬</td>
<td style="text-align:center">‭1110‬</td>
<td style="text-align:center">‭1111‬</td>
<td style="text-align:center">‭0001 1000‬</td>
</tr>
<tr>
<td style="text-align:center">1xxx</td>
<td style="text-align:center">‭1xxx‬</td>
<td style="text-align:center">‭1xxx‬</td>
<td style="text-align:center">1xxx</td>
<td style="text-align:center">‭1xxx</td>
<td style="text-align:center">‭1xxx</td>
<td style="text-align:center">‭1xxx</td>
<td style="text-align:center">‭1xxx</td>
<td style="text-align:center">‭xxxx 1xxx</td>
</tr>
</tbody>
</table>
</div>
<p>由上四张表可以看出：第$g_i$组检测位的二进制代码中，从右往左数第$i$位都为1，即为每个检测小组所检测的检测位的规律</p>
<p>这种小组划分有如下特点：</p>
<ul>
<li>每个小组$g_i$有一位且仅有一位为它独占，这一位是其他小组所没有的，即$g_i$小组独占第$2^{i-1}$位$i=1,2,3…$</li>
<li>每两个小组$g_i$和$g_j$共同占有一位是其他小组没有的，即每两个小组$g_i$和$g_j$共同占有第$2^{i-1}+2^{j-1}$位$i,j=1,2,3…$</li>
<li>每三个小组$g_i、g_j和g_l$共同占有第$2^{i-1}+2^{j-1}+2^{l-1}$位，是其他小组所没有的。</li>
<li>以此类推，便可确定每组所包含的各位</li>
</ul>
<p>例如，欲传送信息为$b_4b_3b_2b_1(n=4)$，根据$2^k \geq n+k+1$，可求出配置汉明码需增添检测为$k=3$，且他们位置的安排如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">二进制序号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">名称</td>
<td style="text-align:center">$C_1$</td>
<td style="text-align:center">$C_2$</td>
<td style="text-align:center">$b_4$</td>
<td style="text-align:center">$C_4$</td>
<td style="text-align:center">$b_3$</td>
<td style="text-align:center">$b_2$</td>
<td style="text-align:center">$b_1$</td>
</tr>
</tbody>
</table>
</div>
<p>若按照配偶原则来配置汉明码，则：<br>$C_1$应使$1、3、5、7$位中的“1”的个数位偶数<br>$C_2$应使$2、3、6、7$位中的“1”的个数位偶数<br>$C_4$应使$4、5、6、7$位中的“1”的个数位偶数</p>
<p>令$b_4b_3b_2b_1=0101$，则<br>$C_1=b_4 \bigoplus b_3 \bigoplus b1=0 \bigoplus 1 \bigoplus 1 = 0$<br>$C_2=b_4 \bigoplus b_2 \bigoplus b1=0 \bigoplus 0 \bigoplus 1 = 1$<br>$C_4=b_3 \bigoplus b_2 \bigoplus b1=1 \bigoplus 0 \bigoplus 1 = 0$</p>
<p>故0101的汉明码应为$C_1C_2b_4C_4b_3b_2b_1$，即0100101</p>
<h3 id="2-3-2-汉明码的纠错过程"><a href="#2-3-2-汉明码的纠错过程" class="headerlink" title="2.3.2. 汉明码的纠错过程"></a>2.3.2. 汉明码的纠错过程</h3><p>哈明码的纠错过程实际上是对传送后的汉明码形成新的检测位$P_i(i=1,2,4,8…)$，根据$P_i$的状态，便可直接指出错误的位置。$P_i$的状态是由原检测位$C_i$及其所在小组“1”的个数确定的。倘若按配偶原则配置的汉明码，其传送后形成新的检测位$P_i$应为$0$，否则说明传送有错，并且还可直接指出出错的位置。由于$P_i$于$C_i$有对应关系，故$P_i$可由下式确定：<br>$P_1=1 \bigoplus 3 \bigoplus 5 \bigoplus 7, 即 P_1 =C_1 \bigoplus b_4 \bigoplus b_3 \bigoplus b_1$<br>$P_2=2 \bigoplus 3 \bigoplus 6 \bigoplus 7, 即 P_2 =C_2 \bigoplus b_4 \bigoplus b_2 \bigoplus b_1$<br>$P_4=4 \bigoplus 5 \bigoplus 6 \bigoplus 7, 即 P_4 =C_4 \bigoplus b_3 \bigoplus b_2 \bigoplus b_1$</p>
<p>设已知传送的正确汉明码（按配偶原则配置）为0100101，若传送后接收到的汉明码为0100111，其出错位可按下述步骤确定。<br>令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">二进制序号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">正确的汉明码</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">接收到的汉明码</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>则新的检测位为：</p>
<p>$P_4=4 \bigoplus 5 \bigoplus 6 \bigoplus 7, 即P_4=0 \bigoplus 1 \bigoplus 1 \bigoplus 1 = 1$<br>$P_2=2 \bigoplus 3 \bigoplus 6 \bigoplus 7, 即P_2=1 \bigoplus 0 \bigoplus 1 \bigoplus 1 = 1$<br>$P_1=1 \bigoplus 3 \bigoplus 5 \bigoplus 7, 即P_1=0 \bigoplus 0 \bigoplus 1 \bigoplus 1 = 0$</p>
<p>由此可见，传送结果$P_4$和$P_2$均不是0，显然出了差错。分析发现，只有第6位出错才会同时使$P_4$和$P_2$为1。同时$P_4P_2P_1$所构成的二进制值恰好是出错的位置，即$P_4P_2P_1=110$，表示第6为出错。发现错误后，计算机便自动将错误的第6位“1”纠正位“0”。</p>
]]></content>
      <categories>
        <category>数据校验</category>
      </categories>
      <tags>
        <tag>数据校验</tag>
        <tag>奇偶校验</tag>
        <tag>循环冗余校验</tag>
        <tag>汉明码</tag>
      </tags>
  </entry>
  <entry>
    <title>吴军《数学之美》中的一段话，看了很有感触</title>
    <url>/2019/06/17/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AE%B5%E8%AF%9D/</url>
    <content><![CDATA[<p>最近在读《数学之美》这本书，看到了下面这段话，挺有感触：</p>
<blockquote><p>每当福莱德和我谈起各自少年时的教育，我们都同意这样几个观点。首先，小学生和中学生其实没有必要花那么多时间读书，而他们的社会经验、生活能力以及在那时树立起的志向将帮助他们一生。第二，中学阶段花很多时间比同伴多读的课程，上大学以后用很短的时间就能读完，因为在大学阶段，人的理解能力要强的多。举个例子，在中学需要花500小时才能学会的内容，在大学可能化100小时就够了。因此，一个学生在中小学阶段建立的那一点点优势在大学很快就会丧失殆尽。第三，学习（和教育）是持续一辈子的过程，很多中学成绩优异的亚裔学生进入名校后表现明显不如那些出于兴趣而读书的美国同伴，因为前者持续学习的动力不足。第四，书本的内容可以早学，也可以晚学，但是错过了成长阶段却是无法补回来的。（因此，少年班的做法不足取。）现在中国的好学校里，恐怕百分之九十九的孩子在读书上花费的时间都比我当时要多，更比贾里尼克要多得多，但是这些孩子今天可能有百分之九十九在学术上的建树不如我，更不如贾里尼克。这实在是教育的误区。</p>
<footer><strong>吴军</strong><cite>《数学之美》</cite></footer></blockquote>
]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
        <tag>数学之美</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法简介</title>
    <url>/2019/06/04/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="1-遗传算法简介及其基本原理"><a href="#1-遗传算法简介及其基本原理" class="headerlink" title="1. 遗传算法简介及其基本原理"></a>1. 遗传算法简介及其基本原理</h1><p>&emsp;&emsp;<strong>遗传算法</strong>（Genetic Algorithm，GA）是由美国密歇根大学心理学教授、电子工程学和计算机科学教授John H. Holland首先提出的一种随机自适应的全局搜索算法。遗传算法吸收了生命科学与工程学科中的重要理论成果，用于解决复杂优化问题。其中，达尔文的进化论和以孟德尔的遗传学说为基础的现代遗传学对算法的提出具有最为重要的影响。</p>
<p>&emsp;&emsp;生物的进化过程是一个不断往复的循环过程。在每个循环中，由于自然环境的恶劣、资源的短缺和天敌的侵害等因素，个体必须接受自然的选择。在选择过程中，一部分对自然环境具有较高适应能力的个体得以保存下来形成新的种群。而另一部分个体则由于不适应自然环境而面临被淘汰的危险。经过选择保存下来的群体构成种群，种群中的生物个体进行交配繁衍，保证了种群的发展。交配产生的子代继承了父代的部分特性，而且一般来说，子代要比父代具有更强的环境适应能力。进化过程伴随着种群的变异，种群中部分个体发生基因变异，成为新的个体。这样，经过选择、交配和变异后的种群取代了原来的种群，进入下一个循环。</p>
<p>&emsp;&emsp;遗传算法正是通过模拟自然界中生物的遗传进化过程，对优化问题的最优解进行搜索。算法维护一个代表问题潜在解得群体，对于群体的优化，算法引入了类似自然进化中选择、交配以及变异等算子。遗传算法搜索全局最优解的过程是一个不断迭代的过程（每一次迭代相当于生物进化中的一次循环），知道满足算法的终止条件为止。</p>
<p>&emsp;&emsp;在遗传算法中，问题的每个有效解被称为一个“<strong>染色体</strong>（chromosome）”，相对于群体中的每个生物<strong>个体</strong>（individual）。染色体的具体形式是一个使用特定编码方式生成的编码串。编码串中的每一个编码单元称为“<strong>基因</strong>（gene）”。</p>
<p>&emsp;&emsp;遗传算法通过比较<strong>适应值</strong>（fitness value）区分染色体的优劣，适应值越大的染色体越优秀。<strong>评估函数</strong>（evaluation function）用来计算并确定染色体对应的适应值。</p>
<p>&emsp;&emsp;<strong>选择算子</strong>（selection）按照一定的规则对群体的染色体进行选择，得到父代种群。一般地，越优秀的染色体被选中的次数越多。</p>
<p>&emsp;&emsp;<strong>交配算子</strong>（crossover）作用于每两个成功交配的染色体，染色体交换各自的部分基因，产生两个子代染色体。子代染色体取代父代染色体进入新种群，而没有交配的染色体则直接进入新种群。</p>
<p>&emsp;&emsp;<strong>变异算子</strong>（mutation）使新种群进行小概率的变异。染色体发生变异的基因改变数值，得到新的染色体。经过变异的新种群替代原有种群进入下一次进化。</p>
<p>定义表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>生物遗传进化</th>
<th>遗传算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>群体</td>
<td>问题搜索空间的一组有效解（表现为群体规模$N$）</td>
</tr>
<tr>
<td>种群</td>
<td>经过选择产生的新群体（规模同样为$N$）</td>
</tr>
<tr>
<td>染色体</td>
<td>问题有效解的编码串</td>
</tr>
<tr>
<td>基因</td>
<td>染色体的一个编码单元</td>
</tr>
<tr>
<td>适应能力</td>
<td>染色体的适应值</td>
</tr>
<tr>
<td>交配</td>
<td>两个染色体交换部分基因得到两个新的子代染色体</td>
</tr>
<tr>
<td>变异</td>
<td>染色体某些基因的数值发生改变</td>
</tr>
<tr>
<td>进化结束</td>
<td>算法满足终止条件时结束，输出全局最优解</td>
</tr>
</tbody>
</table>
</div>
<h1 id="2-遗传算法的流程"><a href="#2-遗传算法的流程" class="headerlink" title="2. 遗传算法的流程"></a>2. 遗传算法的流程</h1><p>遗传算法的实现主要包括了一下七个重要问题</p>
<ul>
<li>染色体的编码</li>
<li>群体的初始化</li>
<li>适应值评价</li>
<li>选择种群</li>
<li>种群交配</li>
<li>种群变异</li>
<li>算法流程</li>
</ul>
<p>&emsp;&emsp;这个几个问题尤其是选择算子、交配算子和变异算子的具体实现与算法搜索全局最优解的能力息息相关。在处理不同优化问题时，以上几个方面可能需要根据问题的特定情况采用不同的方法实现，以提高遗传算法的性能。</p>
<h2 id="2-1-染色体编码"><a href="#2-1-染色体编码" class="headerlink" title="2.1. 染色体编码"></a>2.1. 染色体编码</h2><p>&emsp;&emsp;应用遗传算法，需要解决问题解的表示，即染色体的编码方式。染色体编码方式确定是否得当会对接下来染色体的交配和变异操作构成影响。在使用遗传算法解决具体问题时，采用何种编码方案不是一概而论的，应尽量分析问题的特点，制定可行的编码方案。</p>
<p>&emsp;&emsp;目前用于染色体编码的方法有格雷码编码、字母编码、多参数交叉编码等。下面仅介绍<strong>二进制编码方法</strong>（Binary Representation）和<strong>浮点数编码方法</strong>（Float Point Representation）</p>
<h3 id="2-1-1-二进制编码方式"><a href="#2-1-1-二进制编码方式" class="headerlink" title="2.1.1. 二进制编码方式"></a>2.1.1. 二进制编码方式</h3><p>&emsp;&emsp;二进制编码方法产生的染色体是一个二进制符号序列，染色体的每一个基因只能取值$0$或$1$。假定问题定义的有效解空间为$[U_{min},U_{max}]^D$,其中$D$为有效解得变量维数，使用$L$位二进制符号串表示解的一维变量，则得到如下表所示的编码方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制符号串</th>
<th>对应的实际取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0000···0000$</td>
<td>$U_{min}$</td>
</tr>
<tr>
<td>$1111···1111$</td>
<td>$U_{max}$</td>
</tr>
<tr>
<td>$X_LX_{L-1}···X_2X_1$</td>
<td>$U_{min}+\frac{(U_{max}-U_{min}) \sum_{j=1}^{L} {X_j  2^{j-1}}}{2^L-1}$</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;例如，假设$[U_{min},U_{max}]为[1,64]$，采用$6$为二进制符号串进行编码，则某个二进制符号串$010101$代表了数值$22$</p>
<p>&emsp;&emsp;因此采用$L$位进行编码时的精度为$\frac{U_{max}-U_{min}}{2^L-1}$，可见该种方法在编码的精度方面是较差的。当要求采用较高的精度或表示较大范围的数时，必须通过增加$L$来达到要求。可是当$L$变得很大时，将增加算法操作复杂度和运算量。所以二进制编码在解决某些精度要求较高或解含有多个变量的优化问题时，表现得不尽人意。</p>
<h3 id="2-1-2-浮点数编码方式"><a href="#2-1-2-浮点数编码方式" class="headerlink" title="2.1.2. 浮点数编码方式"></a>2.1.2. 浮点数编码方式</h3><p>&emsp;&emsp;浮点数编码方法中，染色体的长度等于问题定义的解的变量个数，染色体的每一个基因等于解的每一维变量。例如待求解问题的一个有效解为$X_i=(x_{i}^{1},x_{i}^{2},···,x_{i}^{D-1},x_{i}^{D})$，其中D为解的变量维数。则该解对应的染色体编码为$(x_{i}^{1},x_{i}^{2},···,x_{i}^{D-1},x_{i}^{D})$。</p>
<p>&emsp;&emsp;浮点数编码方式适合于表示取值范围较大的数值，对降低采用遗传算法对染色体进行处理的复杂性起到了很好的作用。</p>
<h2 id="2-2-群体的初始化"><a href="#2-2-群体的初始化" class="headerlink" title="2.2. 群体的初始化"></a>2.2. 群体的初始化</h2><p>&emsp;&emsp;遗传算法在一个给定的初始化进化种群中进行迭代搜索。一般情况下，在群体初始化阶段采用的是随机数初始方法。采用生成随机数的方式，对染色体的每一维变量进行初始化赋值。如果在初始化时保证初始群体已经是一定程度上的优良群体的话，将能够有效提高算法找到全局最优解的能力。</p>
<h2 id="2-3-适应值评价"><a href="#2-3-适应值评价" class="headerlink" title="2.3. 适应值评价"></a>2.3. 适应值评价</h2><p>&emsp;&emsp;评价函数用于评估各个染色体的适应值，进而区分优劣。评价函数常常根据问题的优化目标来确定，如在求解函数优化问题时，问题定义的目标函数可以作为评价函数的原型。对于求解最大值的问题，可以按照遗传算法的规定认为适应值越大染色体越优。对于其他优化问题，问题定义的目标函数必须经过一定的变换。例如，应用求解某个函数的最小值，可对问题定义的目标函数$f(X)$进行以下变换，得到算法的评价函数$Eval(C)$</p>
<script type="math/tex; mode=display">Eval(C) = - f(X)</script><p>其中$X$表示一个有效解，$C$表示$X$对应的染色体。</p>
<h2 id="2-4-选择算子"><a href="#2-4-选择算子" class="headerlink" title="2.4. 选择算子"></a>2.4. 选择算子</h2><p>&emsp;&emsp;种群的选择操作使用<strong>轮盘赌选择算法</strong>（roulette wheel selection）。轮盘赌选择算法是遗传算法中最经常使用的选择算法，其基本思想是基于概率的随机选择。<br>&emsp;&emsp;轮盘赌选择算法首先根据群体中每个染色体的适应值得到群体所有染色体的适应值总和，并分别计算每个染色体适应值与群体适应值总和的比$P_i$；其次假设一个具有$N$个扇区的轮盘，每个扇区对应群体中的一个染色体，扇区的大小与对应染色体的$P_i$成正比关系。<br>&emsp;&emsp;每次选择就转动一次轮盘，轮盘转动停止时指针停留的扇区对应的染色体即被选中进入种群。一次进行$N$次选择即可得到规模同样为$N$的种群。较优染色体的$P$值较大，被选择的概率也就相对较大。但由于选择过程具有随机性，并不能保证每次选择均选中这些较优的染色体，因此较差染色体也有一定的生存空间。</p>
<h2 id="2-5-交配算子"><a href="#2-5-交配算子" class="headerlink" title="2.5. 交配算子"></a>2.5. 交配算子</h2><p>&emsp;&emsp;在染色体交配阶段,每个染色体能否进行交配由交配概率$P_c$(一般取值为$0.4~0.99$之间)决定，其具体过程为：对于每个染色体，如果$Random(0,1)$小于$P_c$则表示该染色体可进行交配操作，其中$Random(0,1)$为$[0,1]$间均匀分布的随机数产生器，否则染色体不参与交配直接复制到新种群中。<br>&emsp;&emsp;每两个按照$P_c$交配概率选择出来的染色体进行交配，经过交换各自的部分基因，产生两个新的子代染色体。其具体操作是随机产生一个有效的交配位置，染色体交换位于该交配位置后的所有基因。参与交配的父代染色体个数与产生的子代染色体个数一样，因此新种群的规模依然为$N$。</p>
<h2 id="2-6-变异算子"><a href="#2-6-变异算子" class="headerlink" title="2.6. 变异算子"></a>2.6. 变异算子</h2><p>&emsp;&emsp;染色体的编译作用于基因之上，对于交配后新种群中染色体的每一位基因，根据变异概率$P_m$判断该基因是否变异。如果$Random(0,1)$小于$P_m$，则改变该基因的取值；否则该基因不发生变异，保持不变。</p>
<p>&emsp;&emsp;为了保持遗传算法较好的运行性能，变异概率$P_m$应该设置在一个合适的范围内。变异操作通过改变原有染色体的基因，在提高群体多样性方面具有明显的促进作用。如果$P_m$过小，算法容易早熟，在算法运行过程中，已找到的较优解可能在变异过程中遭到破坏；如果$P_m$过大，可能会导致算法目前所处的较好的搜索状态倒退回到原来较差的情况。因此，应该讲种群的变异限制在一定范围内。一般地，$P_m$可设定在$0.001~0.1之间$</p>
<h2 id="2-7-算法流程"><a href="#2-7-算法流程" class="headerlink" title="2.7. 算法流程"></a>2.7. 算法流程</h2><p>遗传算法的基本步骤：</p>
<p>$1.$ 初始化规模为$N$的群体，其中染色体每个基因的值采用随机数产生器生成。当前进化代数$Generation=0$<br>$2.$ 采用评价函数对群体中所有染色体进行评价，分别计算每个染色体的适应值，保存适应值最大的染色体$Best$<br>$3.$ 采用轮盘赌选择算法对群体中的染色体进行选择操作，产生规模同为$N$的种群。<br>$4.$ 按照概率$P_c$从种群中选择染色体进行交配。每两个进行交配的父代染色体，交换部分基因，产生两个新的子代染色体，子代染色体取代父代染色体进入新种群。没有进行交配的染色体则直接复制进入新种群。<br>$5.$ 按照概率$P_m$对新种群中染色体的基因进行变异操作。发生变异的基因数值发生改变。变异后的染色体取代原有染色体进入新群体，未发生变异的染色体直接进入新群体。<br>$6.$ 变异后的新群体取代原有群体，重新计算群体中各个染色体的适应值。倘若群体的最大适应值大于$Best$，则以该最大适应值对应的染色体替代$Best$<br>$7.$ 当前进化代数$Generation$加$1$。如果$Generation$超过规定的最大进化代数或$Best$达到规定的误差要求，算法结束；否则回到步骤$3$</p>
<p>注：染色体的交配和变异操作均是在选择后进行的。</p>
<p><img src="遗传算法流程图.png" alt="遗传算法流程图"></p>
]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算智能</tag>
      </tags>
  </entry>
  <entry>
    <title>计算智能——最优化问题</title>
    <url>/2019/06/04/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-最优化问题"><a href="#1-最优化问题" class="headerlink" title="1. 最优化问题"></a>1. 最优化问题</h1><p>&emsp;&emsp;最优化问题是在科学研究和生产实践中经常遇到的问题。人类所从事的一切生产或社会活动均是有目的的，其行为总是在特定的价值观念或审美取向的支配下进行的，因此经常面临求解一个可行的甚至是最优的方案的决策问题，这就是所谓的最优化问题（Optimization Problem）</p>
<p>最优化问题的求解模型:</p>
<script type="math/tex; mode=display">
min f(X), X \in D</script><p>其中$D$是问题的解空间，$X$是$D$中的一个合法解。一般可将$X$表示为$X=(x_1,x_2,…,x_n)$，表示一组决策变量。最优化问题就是在解空间中寻找一个合法的解$X$(一组最佳的决策变量)，使得$X$对应的函数值$f(X)$最小(最大)。</p>
<p>&emsp;&emsp;根据决策变量$x_i$的取值类型，可以将最优化问题分为函数最优化问题和组合最优化问题问题两大类。称决策变量均为连续变量的最优化问题为函数优化问题；若一个最优化问题的全部决策变量均为离散取值，则成为组合优化问题。现实应用问题中的数学模型多为混合型，即模型的部分决策变量为连续性，部分决策变量为离散型。</p>
<h2 id="1-1-函数优化问题"><a href="#1-1-函数优化问题" class="headerlink" title="1.1. 函数优化问题"></a>1.1. 函数优化问题</h2><p>&emsp;&emsp;函数优化问题对应的决策变量均为连续变量,优化问题$f$的目标函数值取决于其对应的连续变量$x_1,x_2,…x_n$的取值。在这种问题中，需要优化的变量的取值是某个连续区间上的值,是一个实数。各个决策变量之间可能是独立的，也可能是相互关联、相互制约的，它们的取值组合构成了问题的一个解。由于决策变量是连续值，因此对每个变量进行枚举是不可能的。在这种情况下，必须借助优化方法对问题进行求解。</p>
<h2 id="1-2-组合优化问题"><a href="#1-2-组合优化问题" class="headerlink" title="1.2. 组合优化问题"></a>1.2. 组合优化问题</h2><p>&emsp;&emsp;和函数优化问题不同，组合优化问题的决策变量是离散地，例如整数规划问题、0-1规划问题等。</p>
<p>&emsp;&emsp;典型的组合优化问题包括 <strong>旅行商问题（TSP，Traveling Salesman Problem）</strong>和 <strong>0-1背包问题（Zero//One Knapsack Problem，ZKP、0-1KP/KP）</strong> 这两种问题分别是一种基于排序的组合优化问题和一种基于二进制取值的组合优化问题，是组合优化问题的两种重要类型。</p>
<p>百度百科：</p>
<p><a href="https://baike.baidu.com/item/旅行商问题" target="_blank" rel="noopener">旅行商问题</a><br><a href="https://baike.baidu.com/item/背包问题" target="_blank" rel="noopener">0-1背包问题</a></p>
<p>维基百科：</p>
<p><a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">旅行商问题</a><br><a href="https://zh.wikipedia.org/wiki/背包问题" target="_blank" rel="noopener">0-1背包问题</a></p>
<h1 id="2-计算复杂性"><a href="#2-计算复杂性" class="headerlink" title="2. 计算复杂性"></a>2. 计算复杂性</h1><p>&emsp;&emsp;一般而言，最优化都是“难解问题”。以旅行商问题和背包问题为例，虽然它们的定义非常简单易懂，但是寻求到最优解并不是一件容易的事情。直观的看，旅行商问题就是$n$个城市的一个排序问题，如果使用穷举法，需要进行$(n-1)!$次的枚举。背包问题是一个$n$位的二进制的$0、1$取值问题，$0$表示不选择，$1$表示选择，因此有$2^n$种可能。由此课件，仅当问题的规模$n$较小时，穷举法才是可能的。由于问题的解空间随着规模的增大呈指数级增长，因此需要寻求其他有效且高效的算法解决这类问题的大规模实例。</p>
<p>&emsp;&emsp;在计算机科学中，常用 <strong>计算复杂性</strong> （Computational Complexity） 来描述问题的难易程度或者算法的执行效率。问题的计算复杂性是问题规模的函数。</p>
<p>&emsp;&emsp;对于旅行商问题和背包问题这种很难寻求到一种多项式复杂性的算法来进行求解的问题，习惯称为 <strong>NP难</strong> （Non-deterministic Polynomial Hard，NPH）问题，或者<strong>NP完全</strong>（Non-deterministic Polynomial Complete，NPC）问题。</p>
<h1 id="3-智能优化计算方法：计算智能算法"><a href="#3-智能优化计算方法：计算智能算法" class="headerlink" title="3. 智能优化计算方法：计算智能算法"></a>3. 智能优化计算方法：计算智能算法</h1><p>&emsp;&emsp;随着技术的进步，工程实践问题变得越来越复杂，传统的计算方法面临着计算复杂度高、计算实践长等问题，特别是对于一些NP难和NP完全问题，设计用于求解这些问题的精确算法由于其指数级的计算复杂性而令人无法接受。对于这些难解问题，传统的精确算法根本无法在可以忍受的时间内求出解。因此，为了在求解时间和求解精度上去的平衡，人们提出了形形色色具有启发式特征的计算方法，这些算法或模仿生物界的进化过程，或模仿生物的生理构造和身体机能，或模仿动物的群体行为，或模仿人类的思维、语言和记忆过程的特征，或模仿自然界的物理现象，希望通过模拟大自然和人类的智慧实现对问题的优化求解，在可接受的时间内求解得到可接受的解。这些算法就是只能优化算法，也叫 <strong>计算智能</strong>（Computational Intelligence，CI） 算法；</p>
<p>&emsp;&emsp;计算智能是借助自然界（生物界）规律的启示，根据其规模，设计出求解问题的算法。从关系上说，计算智能属于人工智能的一个分支。</p>
<h2 id="3-1-计算智能的分类"><a href="#3-1-计算智能的分类" class="headerlink" title="3.1. 计算智能的分类"></a>3.1. 计算智能的分类</h2><p>&emsp;&emsp;计算智能方法在模拟人脑的联想、记忆、发散思维、非线性推理、模糊概念等传统人工智能难以胜任的方面表现优异。与传统的人工智能技术互相交叉、取长补短。</p>
<p>&emsp;&emsp;计算智能主要包含神经计算、模糊计算和进化计算三大部分。</p>
<p>计算智能的主要分类：</p>
<script type="math/tex; mode=display">
\begin{cases}
    神经计算：人工神经网络算法\\\\
    模糊计算：模糊逻辑\\\\
    进化计算 \begin{cases}
            遗传算法（进化策略、进化规划）\\
            蚁群优化算法\\
            粒子群优化算法\\
            免疫算法\\
            分布估计算法\\
            Memetic算法\\
            ...
            \end{cases}\\\\
    单点搜索\begin{cases}
                模拟退火算法\\
                禁忌搜索算法\\
                ...
            \end{cases}
\end{cases}</script><p>参考书目：</p>
<p>&emsp;&emsp;《计算智能》&emsp;张军、詹志辉编著&emsp;清华大学出版社</p>
<p>PS:</p>
<p>计算智能的内容是我在学习之后整理的，其中有书上的内容，也有自己的理解。</p>
<p>做这个工作的目的呢<br>一是做个记录，方便日后有遗忘或者疑问时查看。<br>二是贴在博客上，大家能共同学习共同进步，也能发现我的错误。</p>
<p>由于本人学识浅薄，整理的内容很可能会有纰漏，没有大牛那么厉害，勿喷<br>如果你发现了什么错误或者有什么新的见解欢迎和我交流讨论。</p>
<p>我的邮箱是 <code>fanyousen98@163.com</code></p>
]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算智能</tag>
        <tag>最优化问题</tag>
      </tags>
  </entry>
  <entry>
    <title>GitBook的安装与使用</title>
    <url>/2019/06/02/GitBook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-GitBook的安装"><a href="#1-GitBook的安装" class="headerlink" title="1. GitBook的安装"></a>1. GitBook的安装</h1><p>首先介绍一下gitbook<br>gitbook是一个软件，使用markdown来编写，使用git来进行版本控制<br>GitBook支持输出多种文档格式,如:</p>
<ul>
<li>静态站点:Git默认输出该格式,生成的静态站点可直接托管搭载GitHub Pages服务上</li>
<li>PDF:需要安装gitbook-pdf依赖</li>
<li>ebook:需要安装ebook-convert依赖</li>
<li>mobi格式</li>
</ul>
<p><a href="https://legacy.gitbook.com/" target="_blank" rel="noopener">GitBook官网</a></p>
<p><a href="https://legacy.gitbook.com/editor" target="_blank" rel="noopener">GitBookEditor</a></p>
<p>有关教程:</p>
<p><a href="http://www.chengweiyang.cn/gitbook/introduction/README.html" target="_blank" rel="noopener">GitBook简明教程</a> &nbsp;<br><a href="https://tonydeng.github.io/gitbook-zh/gitbook-howtouse/index.html" target="_blank" rel="noopener">GitBook命令行速览</a>&nbsp;<br><a href="https://gitbook.zhangjikai.com/" target="_blank" rel="noopener">GitBook教程</a></p>
<h2 id="1-1-安装-node-js"><a href="#1-1-安装-node-js" class="headerlink" title="1.1. 安装 node.js"></a>1.1. 安装 node.js</h2><p><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js官网</a></p>
<p>下载安装文件后,安装即可,安装后将nodejs配置到环境变量中</p>
<p>配置完环境变量后,使用命令行检查下是否安装成功</p>
<p><code>$ node -v</code></p>
<p>配置正确的话,会输出版本号</p>
<h2 id="1-2-安装GitBook"><a href="#1-2-安装GitBook" class="headerlink" title="1.2. 安装GitBook"></a>1.2. 安装GitBook</h2><p>在完成上述步骤后,npm已经可以使用了</p>
<h3 id="1-2-1-安装gitbook-cli"><a href="#1-2-1-安装gitbook-cli" class="headerlink" title="1.2.1. 安装gitbook-cli"></a>1.2.1. 安装gitbook-cli</h3><p><code>$ npm install gitbook-cli -g</code></p>
<p>有的教程没有安装<code>gitbook-cli</code>这一步，<code>gitbook-cli</code>是一个gitbook的命令行工具,通过它可以在电脑上安装和gitbook的多个版本</p>
<p>所以不安装<code>gitbook-cli</code>直接安装gitbook也是可行的，<code>gitbook-cli</code>只是一个版本控制工具</p>
<h3 id="1-2-2-安装GitBook"><a href="#1-2-2-安装GitBook" class="headerlink" title="1.2.2. 安装GitBook"></a>1.2.2. 安装GitBook</h3><p><code>$ npm install gitbook -g</code></p>
<p>安装后命令行执行<code>gitbook -v</code></p>
<p>输出版本号即说明安装成功</p>
<ul>
<li><code>gitbook-cli</code>和<code>gitbook</code>是两个软件</li>
<li><code>gitbook-cli</code>会将下载的<code>gitbook</code>的不同版本放到<code>~/.gitbook</code>文件夹中,可以通过设置<code>GITBOOK_DIR</code>环境变量来指定另外的文件夹</li>
</ul>
<h2 id="1-3-转换文档相关依赖的安装"><a href="#1-3-转换文档相关依赖的安装" class="headerlink" title="1.3. 转换文档相关依赖的安装"></a>1.3. 转换文档相关依赖的安装</h2><h3 id="1-3-1-安装Calibre"><a href="#1-3-1-安装Calibre" class="headerlink" title="1.3.1. 安装Calibre"></a>1.3.1. 安装Calibre</h3><p>安装Calibre也是用来转换文档的，一开始没有安装，在网上搜了搜解决方法，发现是通过安装Calibre来解决的，因为通过此方法解决了问题，所以就暂且认为应该是这样解决的吧</p>
<p>Gitbook在转换文档的时候，需要使用一个叫ebook-convert 的驱动<br>安装Calibre后将Calibre配置到环境变量</p>
<p><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">Calibre官网地址</a></p>
<h3 id="1-3-2-安装gitbook-pdf"><a href="#1-3-2-安装gitbook-pdf" class="headerlink" title="1.3.2. 安装gitbook-pdf"></a>1.3.2. 安装gitbook-pdf</h3><p>命令行执行<code>$ npm install gitbook-pdf -g</code></p>
<p>执行此命令时，当下载一个名为phantomjs的包时，会出现请求未响应的情况，这个时候，可以去phantomjs官网下载安装，安装方法如下：安装phantomjs</p>
<h3 id="1-3-3-安装phantomjs"><a href="#1-3-3-安装phantomjs" class="headerlink" title="1.3.3. 安装phantomjs"></a>1.3.3. 安装phantomjs</h3><p><a href="phantomjs.org/download.html">PhantomJS下载地址</a></p>
<p>根据自己的系统下载对应的版本</p>
<p>PhantomJS是GitBook将markdown文件转pdf/epub等文件时用到的，没有安装PhantomJS转文档的时候会报错</p>
<p>值得注意的是，GitBook好像不支持高版本的PhantomJS，我一开始配置了phantomjs-2.1.1版本,转文档的时候,还是会报错，后来发现是需要低版本的phantomjs，遂去<a href="https://npm.taobao.org/mirrors/phantomjs" target="_blank" rel="noopener">淘宝npm镜像</a>下载了低版本的phantomj，我按照报错信息的要求下载配置了1.9.2版本</p>
<p>下载后解压然后配置到环境变量就OK了</p>
<hr>
<h1 id="2-GitBook的使用"><a href="#2-GitBook的使用" class="headerlink" title="2. GitBook的使用"></a>2. GitBook的使用</h1><h2 id="2-1-gitbook项目结构："><a href="#2-1-gitbook项目结构：" class="headerlink" title="2.1. gitbook项目结构："></a>2.1. gitbook项目结构：</h2><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── book.json</span><br><span class="line">├── README.<span class="built_in">md</span>    </span><br><span class="line">├── SUMMARY.<span class="built_in">md</span>    </span><br><span class="line">├── chapter-<span class="number">1</span>/  </span><br><span class="line">|   ├── README.<span class="built_in">md</span>   </span><br><span class="line">|   └── something.<span class="built_in">md</span>   </span><br><span class="line">└── chapter-<span class="number">2</span>/   </span><br><span class="line">    ├── README.<span class="built_in">md</span>   </span><br><span class="line">    └── something.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<p>各个文件的主要作用:</p>
<h3 id="2-1-1-book-json"><a href="#2-1-1-book-json" class="headerlink" title="2.1.1. book.json"></a>2.1.1. book.json</h3><p>存放配置信息</p>
<h3 id="2-1-2-SUMMARY-md文件"><a href="#2-1-2-SUMMARY-md文件" class="headerlink" title="2.1.2. SUMMARY .md文件"></a>2.1.2. SUMMARY .md文件</h3><p>概要文件主要存放GitBook的文件目录信息，目录就是根据此文件来自动生成的，默认对应的文件是SUMMARY.md,可以在book.json重新定义该文件的对应值.概要文件通过Markdown中列表语法来表示文件的父子关系:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Summary</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Introduction</span>](<span class="link">README.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Part I</span>](<span class="link">part1/README.md</span>)</span><br><span class="line"><span class="bullet">    * </span>[<span class="string">Writing is nice</span>](<span class="link">part1/writing.md</span>)</span><br><span class="line"><span class="bullet">    * </span>[<span class="string">GitBook is nice</span>](<span class="link">part1/gitbook.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Part II</span>](<span class="link">part2/README.md</span>)</span><br><span class="line"><span class="bullet">    * </span>[<span class="string">We love feedback</span>](<span class="link">part2/feedback_please.md</span>)</span><br><span class="line"><span class="bullet">    * </span>[<span class="string">Better tools for authors</span>](<span class="link">part2/better_tools.md</span>)</span><br></pre></td></tr></table></figure>
<p>对应的目录结构如下所示:</p>
<p><img src="https://gitbook.zhangjikai.com/assets/images/summary1.png" alt="目录结构" title="目录结构"></p>
<p>通过使用标题或者水平分割线标志将GitBook分为几个不同的部分:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Summary</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Part I</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Introduction</span>](<span class="link">README.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Writing is nice</span>](<span class="link">part1/writing.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">GitBook is nice</span>](<span class="link">part1/gitbook.md</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### Part II</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">We love feedback</span>](<span class="link">part2/feedback_please.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Better tools for authors</span>](<span class="link">part2/better_tools.md</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Last part without title</span>](<span class="link">part3/title.md</span>)</span><br></pre></td></tr></table></figure>
<p>对应的目录结构如下所示:</p>
<p><img src="https://gitbook.zhangjikai.com/assets/images/summary2.png" alt="目录结构" title="目录结构"></p>
<h3 id="2-1-3-Glossary-词汇表文件"><a href="#2-1-3-Glossary-词汇表文件" class="headerlink" title="2.1.3. Glossary 词汇表文件"></a>2.1.3. Glossary 词汇表文件</h3><p>词汇表文件,默认对应的文件是GLOSSARY.md 该文件主要存储词汇信息,如果在其他页面中出现了该文件中的词汇,鼠标放在词汇上会给出词汇释意</p>
<p>GLOSSARY.md文件的格式如下:</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## Git</span><br><span class="line">分散式版本控制软件</span><br><span class="line"></span><br><span class="line">## Markdown</span><br><span class="line">一种文本标记语言</span><br></pre></td></tr></table></figure>
<h2 id="2-2-GitBook的命令"><a href="#2-2-GitBook的命令" class="headerlink" title="2.2. GitBook的命令"></a>2.2. GitBook的命令</h2><p>列出gitbook所有的命令:</p>
<p><code>gitbook help</code></p>
<p>输出gitbook-cli的帮助信息:</p>
<p><code>gitbook --help</code></p>
<p>初始化gitbook:</p>
<p><code>gitbook init</code></p>
<p>生成静态网页:</p>
<p><code>gitbook build</code></p>
<p>生成静态网页并运行服务器:</p>
<p><code>gitbook serve</code></p>
<p>生成时指定gitbook的版本,本地没有时会先下载安装:</p>
<p><code>gitbook build --gitbook=2.0.1</code></p>
<p>列出本地所有的gitbook版本:</p>
<p><code>gitbook ls</code></p>
<p>列出远程可用的gitbook版本:</p>
<p><code>gitbook ls -remote</code></p>
<p>安装对应的版本:</p>
<p><code>gitbook fetch 标签/版本号</code></p>
<p>更新到gitbook的最新版本:</p>
<p><code>gitbook update</code></p>
<p>卸载对应的gitbook版本:</p>
<p><code>gitbook uninstall 2.0.1</code></p>
<p>制定log的级别:</p>
<p><code>gitbook build --log=debug</code></p>
<p>输出错误信息:</p>
<p><code>gitbook build --debug</code></p>
<h2 id="2-3-GitBook配置文件-book-json"><a href="#2-3-GitBook配置文件-book-json" class="headerlink" title="2.3. GitBook配置文件 book.json"></a>2.3. GitBook配置文件 book.json</h2><ul>
<li>title 标题</li>
<li>author 作者信息</li>
<li>description 书本描述</li>
<li>language 使用的语言</li>
<li>gitbook 制定gitbook版本</li>
<li>root 指定存放GitBook文件的根目录</li>
<li>links 在左侧边栏添加链接</li>
<li>styles 自定义样式</li>
<li>plugins 插件</li>
<li>pluginsConfig 插件配置</li>
<li>structure 设置README,SUMMARY,GLOSSARY等文件</li>
</ul>
<h3 id="2-3-1-title"><a href="#2-3-1-title" class="headerlink" title="2.3.1. title"></a>2.3.1. title</h3><p>设置书本标题</p>
<p><code>&quot;title&quot;:&quot;How to use gitbook&quot;</code></p>
<h3 id="2-3-2-author"><a href="#2-3-2-author" class="headerlink" title="2.3.2. author"></a>2.3.2. author</h3><p>作者的相关信息</p>
<p><code>&quot;author&quot; : &quot;fanyousen&quot;</code></p>
<h3 id="2-3-3-description"><a href="#2-3-3-description" class="headerlink" title="2.3.3. description"></a>2.3.3. description</h3><p>本书的简单描述</p>
<p>“description” : “本书描述”</p>
<h3 id="2-3-4-links"><a href="#2-3-4-links" class="headerlink" title="2.3.4. links"></a>2.3.4. links</h3><p>在左侧导航栏添加链接信息</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"links"</span>:&#123;</span><br><span class="line">    <span class="string">"sidebar"</span>:&#123;</span><br><span class="line">        <span class="string">"home"</span>:<span class="string">"http://winslow.cn"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-styles"><a href="#2-3-5-styles" class="headerlink" title="2.3.5. styles"></a>2.3.5. styles</h3><p>自定义页面样式,默认情况下generator对应的css文件</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"styles"</span>:&#123;</span><br><span class="line">    <span class="string">"website"</span>:<span class="string">"styles/website.css"</span>,</span><br><span class="line">    <span class="string">"ebook"</span>:<span class="string">"styles/ebook.css"</span>,</span><br><span class="line">    <span class="string">"pdf"</span>:<span class="string">"styles/pdf.css"</span>,</span><br><span class="line">    <span class="string">"mobi"</span>:<span class="string">"styles/mobi.css"</span>,</span><br><span class="line">    <span class="string">"epub"</span>:<span class="string">"styles/epub.css"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如使<code>&lt;h1&gt;&lt;h2&gt;</code>标签下边框,可以在website.css中设置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#EFEAEA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-structure"><a href="#2-3-6-structure" class="headerlink" title="2.3.6. structure"></a>2.3.6. structure</h3><p>指定README/SUMMARY/GLOSSARY和LANGUAGE对应的文件名,下面是默认值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义和默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>structure.readme</td>
<td>Readme file name (defaults to README.md)</td>
</tr>
<tr>
<td>structure.summary</td>
<td>Summary file name (defaults to SUMMARY.md)</td>
</tr>
<tr>
<td>structure.glossary</td>
<td>Glossary file name (defaults to GLOSSARY.md)</td>
</tr>
<tr>
<td>structure.language</td>
<td>Languages file name (defaults to LANGS.md)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-7-plugin"><a href="#2-3-7-plugin" class="headerlink" title="2.3.7. plugin"></a>2.3.7. plugin</h3><p>配置使用的插件</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>:[</span><br><span class="line">    <span class="string">'disqus'</span>,</span><br><span class="line">    <span class="string">"search"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>添加插件后需要执行<code>$ gitbook install</code>来安装新的插件</p>
<p>Gitbook默认带有5个插件</p>
<ul>
<li>highlight</li>
<li>search</li>
<li>sharing</li>
<li>font-settings</li>
<li>livereload</li>
</ul>
<p>若要去除自带的插件,可以在插件名称前面加<code>-</code></p>
<p>如去除search插件</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>:[</span><br><span class="line">    <span class="string">"-search"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="2-3-8-pluginsConfig"><a href="#2-3-8-pluginsConfig" class="headerlink" title="2.3.8. pluginsConfig"></a>2.3.8. pluginsConfig</h3><p>配置插件的属性</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">"pluginsConfig:"</span>&#123;</span><br><span class="line">    <span class="attr">"fontsettings"</span>:&#123;</span><br><span class="line">        <span class="attr">"theme"</span>:<span class="string">"sepia"</span>,</span><br><span class="line">        <span class="attr">"family"</span>:<span class="string">"serif"</span>,</span><br><span class="line">        <span class="attr">"size"</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-插件"><a href="#3-插件" class="headerlink" title="3. 插件"></a>3. 插件</h1><p>若要指定插件的版本可以使用: <code>plugin@version</code></p>
<p>部分插件</p>
<ul>
<li>Disqus - Disqus 评论</li>
<li>Search Plus - 支持中文搜索</li>
<li>Prsim - 使用 Prism.js 高亮代码</li>
<li>Advanced Emoji - 支持 emoji 表情</li>
<li>Github - 添加github图标</li>
<li>Github Buttons - 添加项目在 Github 上的 star、fork、watch 信息</li>
<li>Ace Plugin - 支持ace</li>
<li>Emphasize - 为文字加上底色</li>
<li>KaTex - 支持数学公式</li>
<li>Include Codeblock - 用代码块显示包含文件的内容</li>
<li>Splitter - 使侧边栏的宽度可以自由调节</li>
<li>Mermaid-gb3 - 支持渲染 Mermaid 图表</li>
<li>Puml - 支持渲染 uml 图</li>
<li>Graph - 使用 function-plot 绘制数学函数图</li>
<li>Chart - 绘制图形</li>
<li>Sharing-plus - 分享当前页面</li>
<li>Tbfed-pagefooter - 为页面添加页脚</li>
<li>Expandable-chapters-small - 使左侧的章节目录可以折叠</li>
<li>Sectionx - 将页面分块显示</li>
<li>GA - Google 统计</li>
<li>3-ba - 百度统计</li>
<li>Donate - 打赏插件</li>
<li>Local Video - 使用 Video.js 播放本地视频</li>
<li>Simple-page-toc - 自动生成本页的目录结构</li>
<li>Anchors - 添加 Github 风格的锚点</li>
<li>Anchor-navigation-ex - 添加Toc到侧边悬浮导航以及回到顶部按钮</li>
<li>Edit Link - 链接到当前页源文件上</li>
<li>Sitemap-general - 生成sitemap</li>
<li>Favicon - 更改网站的 favicon.ico</li>
<li>Todo - 添加 Todo 功能</li>
<li>Terminal - 模拟终端样式</li>
<li>Copy-code-button - 为代码块添加复制按钮</li>
<li>Alerts - 添加不同 alerts 样式的 blockquotes</li>
<li>Include-csv - 显示 csv 文件内容</li>
<li>Musicxml - 支持 musicxml 格式的乐谱渲染</li>
<li>Klipse - 集成 Kplise (online code evaluator)</li>
<li>Versions-select - 添加版本选择的下拉菜单</li>
<li>Rss - 添加 rss 订阅功能``</li>
</ul>
]]></content>
      <categories>
        <category>安装部署教程</category>
      </categories>
      <tags>
        <tag>GitBook</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指向数组的指针</title>
    <url>/2016/09/20/C%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="数组的指针"><a href="#数组的指针" class="headerlink" title="数组的指针"></a>数组的指针</h2><p>在C语言中，数组名是一个指向数组中第一个元素的常量指针。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p =  <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，array的值为&amp;array[0]，即数组第一个元素的地址。<br>因此对于数组，数组名已经是一个指针变量了，将数组地址赋给指针变量时，不需要使用取址符&amp;，如<code>int *p = array;</code>。</p>
<p>然而对于其他类型的变量，取值时需要使用取址符&amp;，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，如果写成<code>int *p = a;</code> 则会将10强制赋给指针变量p。</p>
<h2 id="使用指针访问数组"><a href="#使用指针访问数组" class="headerlink" title="使用指针访问数组"></a>使用指针访问数组</h2><p>若把数组中第一个元素的地址赋给指针变量p，则可使用<code>*(p + i)</code> 来访问数组中其他的元素，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d] = *(p + %d) = %d \n"</span>, i, i, *(p + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[0] = *(p + 0) = 1</span><br><span class="line">a[1] = *(p + 1) = 2</span><br><span class="line">a[2] = *(p + 2) = 3</span><br><span class="line">a[3] = *(p + 3) = 4</span><br><span class="line">a[4] = *(p + 4) = 5</span><br></pre></td></tr></table></figure>
<p>当然直接使用数组名也可以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d] = *(array + %d) = %d \n"</span>, i, i, *(<span class="built_in">array</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[0] = *(array + 0) = 1</span><br><span class="line">a[1] = *(array + 1) = 2</span><br><span class="line">a[2] = *(array + 2) = 3</span><br><span class="line">a[3] = *(array + 3) = 4</span><br><span class="line">a[4] = *(array + 4) = 5</span><br></pre></td></tr></table></figure>
<div class="note danger">
            <h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>值得注意的是，对于指针变量 p 可以使用<code>++</code>或<code>--</code>来做自增或自减运算<br>但是对于数组名array，虽然array也是一个指针，但它是一个常量指针，常量值不能改变，所以对array使用<code>--</code>或<code>++</code>是不正确的</p>
          </div>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基本数据类型</title>
    <url>/2016/09/15/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="1-C语言的数据表现形式"><a href="#1-C语言的数据表现形式" class="headerlink" title="1. C语言的数据表现形式"></a>1. C语言的数据表现形式</h1><h2 id="1-1-常量和变量"><a href="#1-1-常量和变量" class="headerlink" title="1.1. 常量和变量"></a>1.1. 常量和变量</h2><p>在C语言中，数据有两种表现形式：常量和变量</p>
<h3 id="1-1-1-常量"><a href="#1-1-1-常量" class="headerlink" title="1.1.1. 常量"></a>1.1.1. 常量</h3><blockquote>
<p>在程序运行过程中，其值不能改变的量称为常量</p>
</blockquote>
<p>常用的常量有以下几种：</p>
<p>（1）整型常量<br>整型常量即整数（没有小数部分），如123，-90，87等都是整型常量</p>
<p>（2）实型常量<br>实型常量即实数（可以表示带有小数的数），实型常量有两种表示形式：<br>十进制小数形式：如123.123，0.454，-98.98，0.0，1.0等<br>指数形式：如12.35e3（表示$12.35 \times 10^3$），-354.2e-34（表示$-354.2 \times 10^{-34}$）</p>
<p>（3）字符常量<br>字符常量分为两种</p>
<p>普通字符：<br>用单撇号括起来的<strong>一个</strong>字符，如: ‘a’, ‘b’, ‘c’, ‘2’ ,’?’</p>
<blockquote>
<p>注意：这里的单撇号’是英文符号</p>
</blockquote>
<p>转义字符：<br>转义字符是一种控制字符，在程序中无法用一般形式的字符来表示，只能用反斜杠\开头这样的特殊形式来表示，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转义字符</th>
<th>字符值</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>\’</td>
<td>一个单撇号（’）</td>
<td>输出一个单撇号</td>
</tr>
<tr>
<td>\\</td>
<td>一个反斜杠（\）</td>
<td>输出反斜杠</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>将当前位置移到下一行的开头</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>上表列出的字符称为转义字符，意思就是将 \ 后面的字符转换成另外的意思，如’\n’不代表字符n而代表换行</p>
<p>值得注意的是，字符常量在计算机存储单元中存储时，并不是存储字符本身，而是将字符对应的代码（一般采用<sup><a href="#fn_ASCII" id="reffn_ASCII">ASCII</a></sup>码）存储在内存单元中，如字符’a’的ASCII码时97，在存储字符’a’时就是将97的二进制形式存放在内存单元中。</p>
<p>（4）字符串常量<br>如”boy”, “232”等，用双撇号将若干个字符括起来，字符串常量是双撇号中的全部字符（不包括双撇号）。单撇号内只能包括一个字符，而双撇号内可以包含多个字符。</p>
<p>（5）符号常量<br>用#define指令，指定用一个符号名称代表一个常量。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="comment">// 经过以上指令的指定后，本文件中此行开始的所有的PI都代表3.14</span></span><br><span class="line"><span class="comment">// 在对程序编译前，预处理器先对PI进行处理，把所有PI全部置换为3.14.这种用一个符号代表一个常量的，称为符号常量</span></span><br><span class="line"><span class="comment">// 在预编译后符号常量已全部变成字面常量（3.14），使用符号常量有以下好处：</span></span><br><span class="line"><span class="comment">// （1）含义清楚，看程序时从PI就可大致清楚它代表圆周率。</span></span><br><span class="line"><span class="comment">// （2）在需要改变程序中多出用到的同一个常量时，能做到一改全改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要注意区分符号常量和变量，符号常量不是变量。符号常量不占内存，只是一个临时符号，在预编译后这个符号就不存在了，故不能对符号常量赋新值。为与变量有所区别，习惯上符号常量常用大写表示。如PI，PRICE等。</p>
</blockquote>
<h3 id="1-1-2-变量"><a href="#1-1-2-变量" class="headerlink" title="1.1.2. 变量"></a>1.1.2. 变量</h3><p>变量代表一个有名字的、具有特定属性的一个存储单元，用来存放数据，也就是存放变量的值。在程序运行期间变量的值时可以改变的。变量必须先定义后使用。在定义变量时指定该变量的名称和类型。<br>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// a 是变量名，4是变量的值也就是存放在变量a的内存单元中的数据，int是变量的类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量名实际上是以一个名字代表的存储地址，在对程序编译连接时由编译系统给每一个变量名分配对应的内存地址。从变量中取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据。</p>
</blockquote>
<h3 id="1-1-3-常变量"><a href="#1-1-3-常变量" class="headerlink" title="1.1.3. 常变量"></a>1.1.3. 常变量</h3><p>在C99中允许使用常变量，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 表示a被定义为一个整型变量，指定其值为3，而且在变量存在期间其值不能改变。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>常变量与常量的异同是：常变量具有变量的基本属性，有类型，占存储单元，只是不允许改变其值。可以说，常变量是具有名字的不变量，而常量是没有名字的不变量。由名子就便于在程序中被引用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义符号常量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="comment">// 定义常变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>符号常量与常变量异同：符号常量不占用内存单元，在预编译后，符号常量就不存在了（全部置换为3.14）。而常变量要占用存储单元，由变量值，只是该值不能再改变而已。从使用的角度看，常变量具有符号常量的优点，而且使用更方便，因此有了常变量后可以不必多使用符号常量。</p>
</blockquote>
<h3 id="1-1-4-C语言的表示符规范"><a href="#1-1-4-C语言的表示符规范" class="headerlink" title="1.1.4. C语言的表示符规范"></a>1.1.4. C语言的表示符规范</h3><p>在计算机高级语言中，用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列统称为标识符。<br>如<code>int a =3; \\a 就是一个表示符，也即变量</code>。</p>
<p>C语言规定标识符只能由字母、数字和下划线3中字符组成，且第一个字符必须为字母或下划线。另外要注意C语言是大小写敏感的如<code>sum 和 SUM</code>是两个不同的变量名。</p>
<h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h1><p>所谓类型，就是对数据分配存储单元的安排，包括存储单元的长度（占多少字节）以及数据的存储形式。不同的类型分配不同的长度和存储形式。<br>C语言常用数据类型(有* 的是C99所增加的)：</p>
<script type="math/tex; mode=display">
数据类型\begin{cases}
    基本类型\begin{cases}
        整型类型\begin{cases}
            基本整型 int\\
            短整型 short\ int\\
            长整型 long\ int\\
            * 双长整型 long\ long\ int\\
            字符型 char\\
            * 布尔型 bool
        \end{cases}\\
        浮点类型\begin{cases}
            单精度浮点型 float\\
            双精度浮点型 double\\
            复数浮点型 float\_complex,double\_comple,long\ long\_comple
        \end{cases}
    \end{cases}\\
    枚举类型 enum\\
    空类型 void\\
    派生类型\begin{cases}
        指针类型 *\\
        数组类型 []\\
        结构题类型 struct\\
        共用体类型 union\\
        函数类型
    \end{cases}
\end{cases}</script><h1 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3. 参考文献"></a>3. 参考文献</h1><blockquote>
<p>《C程序设计》谭浩强</p>
</blockquote>
<blockquote id="fn_ASCII">
<sup>ASCII</sup>. (American Standard Code for Information Interchange): 美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。<a href="https://baike.baidu.com/item/ASCII/309296" target="_blank" rel="noopener">ASCII百度百科介绍</a><a href="#reffn_ASCII" title="Jump back to footnote [ASCII] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
