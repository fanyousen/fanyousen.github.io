<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[遗传算法及其实现]]></title>
    <url>%2F2019%2F06%2F04%2F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[遗传算法简介及其基本原理 遗传算法（Genetic Algorithm，GA）是由美国密歇根大学心理学教授、电子工程学和计算机科学教授John H. Holland首先提出的一种随机自适应的全局搜索算法。遗传算法吸收了生命科学与工程学科中的重要理论成果，用于解决复杂优化问题。其中，达尔文的进化论和以孟德尔的遗传学说为基础的现代遗传学对算法的提出具有最为重要的影响。 生物的进化过程是一个不断往复的循环过程。在每个循环中，由于自然环境的恶劣、资源的短缺和天敌的侵害等因素，个体必须接受自然的选择。在选择过程中，一部分对自然环境具有较高适应能力的个体得以保存下来形成新的种群。而另一部分个体则由于不适应自然环境而面临被淘汰的危险。经过选择保存下来的群体构成种群，种群中的生物个体进行交配繁衍，保证了种群的发展。交配产生的子代继承了父代的部分特性，而且一般来说，子代要比父代具有更强的环境适应能力。进化过程伴随着种群的变异，种群中部分个体发生基因变异，成为新的个体。这样，经过选择、交配和变异后的种群取代了原来的种群，进入下一个循环。 遗传算法正是通过模拟自然界中生物的遗传进化过程，对优化问题的最优解进行搜索。算法维护一个代表问题潜在解得群体，对于群体的优化，算法引入了类似自然进化中选择、交配以及变异等算子。遗传算法搜索全局最优解的过程是一个不断迭代的过程（每一次迭代相当于生物进化中的一次循环），知道满足算法的终止条件为止。 在遗传算法中，问题的每个有效解被称为一个“染色体（chromosome）”，相对于群体中的每个生物个体（individual）。染色体的具体形式是一个使用特定编码方式生成的编码串。编码串中的每一个编码单元称为“基因（gene）”。 遗传算法通过比较适应值（fitness value）区分染色体的优劣，适应值越大的染色体越优秀。评估函数（evaluation function）用来计算并确定染色体对应的适应值。 选择算子（selection）按照一定的规则对群体的染色体进行选择，得到父代种群。一般地，越优秀的染色体被选中的次数越多。 交配算子（crossover）作用于每两个成功交配的染色体，染色体交换各自的部分基因，产生两个子代染色体。子代染色体取代父代染色体进入新种群，而没有交配的染色体则直接进入新种群。 变异算子（mutation）使新种群进行小概率的变异。染色体发生变异的基因改变数值，得到新的染色体。经过变异的新种群替代原有种群进入下一次进化。 定义表 生物遗传进化 遗传算法 群体 问题搜索空间的一组有效解（表现为群体规模NNN） 种群 经过选择产生的新群体（规模同样为NNN） 染色体 问题有效解的编码串 基因 染色体的一个编码单元 适应能力 染色体的适应值 交配 两个染色体交换部分基因得到两个新的子代染色体 变异 染色体某些基因的数值发生改变 进化结束 算法满足终止条件时结束，输出全局最优解 遗传算法的流程 遗传算法的实现主要包括了一下七个重要问题 染色体的编码 群体的初始化 适应值评价 选择种群 种群交配 种群变异 算法流程 这个几个问题尤其是选择算子、交配算子和变异算子的具体实现与算法搜索全局最优解的能力息息相关。在处理不同优化问题时，以上几个方面可能需要根据问题的特定情况采用不同的方法实现，以提高遗传算法的性能。 染色体编码 应用遗传算法，需要解决问题解的表示，即染色体的编码方式。染色体编码方式确定是否得当会对接下来染色体的交配和变异操作构成影响。在使用遗传算法解决具体问题时，采用何种编码方案不是一概而论的，应尽量分析问题的特点，制定可行的编码方案。 目前用于染色体编码的方法有格雷码编码、字母编码、多参数交叉编码等。下面仅介绍二进制编码方法（Binary Representation）和浮点数编码方法（Float Point Representation） 二进制编码方式 二进制编码方法产生的染色体是一个二进制符号序列，染色体的每一个基因只能取值000或111。假定问题定义的有效解空间为[Umin,Umax]D[U_{min},U_{max}]^D[Umin​,Umax​]D,其中DDD为有效解得变量维数，使用LLL位二进制符号串表示解的一维变量，则得到如下表所示的编码方式： 二进制符号串 对应的实际取值 0000⋅⋅⋅00000000···00000000⋅⋅⋅0000 UminU_{min}Umin​ 1111⋅⋅⋅11111111···11111111⋅⋅⋅1111 UmaxU_{max}Umax​ XLXL−1⋅⋅⋅X2X1X_LX_{L-1}···X_2X_1XL​XL−1​⋅⋅⋅X2​X1​ Umin+(Umax−Umin)∑j=1LXj2j−12L−1U_{min}+\frac{(U_{max}-U_{min}) \sum_{j=1}^{L} {X_j 2^{j-1}}}{2^L-1}Umin​+2L−1(Umax​−Umin​)∑j=1L​Xj​2j−1​ 例如，假设[Umin,Umax]为[1,64][U_{min},U_{max}]为[1,64][Umin​,Umax​]为[1,64]，采用666为二进制符号串进行编码，则某个二进制符号串010101010101010101代表了数值222222 因此采用LLL位进行编码时的精度为Umax−Umin2L−1\frac{U_{max}-U_{min}}{2^L-1}2L−1Umax​−Umin​​，可见该种方法在编码的精度方面是较差的。当要求采用较高的精度或表示较大范围的数时，必须通过增加LLL来达到要求。可是当LLL变得很大时，将增加算法操作复杂度和运算量。所以二进制编码在解决某些精度要求较高或解含有多个变量的优化问题时，表现得不尽人意。 浮点数编码方式 浮点数编码方法中，染色体的长度等于问题定义的解的变量个数，染色体的每一个基因等于解的每一维变量。例如待求解问题的一个有效解为Xi=(xi1,xi2,⋅⋅⋅,xiD−1,xiD)X_i=(x_{i}^{1},x_{i}^{2},···,x_{i}^{D-1},x_{i}^{D})Xi​=(xi1​,xi2​,⋅⋅⋅,xiD−1​,xiD​)，其中D为解的变量维数。则该解对应的染色体编码为(xi1,xi2,⋅⋅⋅,xiD−1,xiD)(x_{i}^{1},x_{i}^{2},···,x_{i}^{D-1},x_{i}^{D})(xi1​,xi2​,⋅⋅⋅,xiD−1​,xiD​)。 浮点数编码方式适合于表示取值范围较大的数值，对降低采用遗传算法对染色体进行处理的复杂性起到了很好的作用。 群体的初始化 遗传算法在一个给定的初始化进化种群中进行迭代搜索。一般情况下，在群体初始化阶段采用的是随机数初始方法。采用生成随机数的方式，对染色体的每一维变量进行初始化赋值。如果在初始化时保证初始群体已经是一定程度上的优良群体的话，将能够有效提高算法找到全局最优解的能力。 适应值评价 评价函数用于评估各个染色体的适应值，进而区分优劣。评价函数常常根据问题的优化目标来确定，如在求解函数优化问题时，问题定义的目标函数可以作为评价函数的原型。对于求解最大值的问题，可以按照遗传算法的规定认为适应值越大染色体越优。对于其他优化问题，问题定义的目标函数必须经过一定的变换。例如，应用求解某个函数的最小值，可对问题定义的目标函数f(X)f(X)f(X)进行以下变换，得到算法的评价函数Eval(C)Eval(C)Eval(C) Eval(C)=−f(X)Eval(C) = - f(X) Eval(C)=−f(X) 其中XXX表示一个有效解，CCC表示XXX对应的染色体。 选择算子 种群的选择操作使用轮盘赌选择算法（roulette wheel selection）。轮盘赌选择算法是遗传算法中最经常使用的选择算法，其基本思想是基于概率的随机选择。 轮盘赌选择算法首先根据群体中每个染色体的适应值得到群体所有染色体的适应值总和，并分别计算每个染色体适应值与群体适应值总和的比PiP_iPi​；其次假设一个具有NNN个扇区的轮盘，每个扇区对应群体中的一个染色体，扇区的大小与对应染色体的PiP_iPi​成正比关系。 每次选择就转动一次轮盘，轮盘转动停止时指针停留的扇区对应的染色体即被选中进入种群。一次进行NNN次选择即可得到规模同样为NNN的种群。较优染色体的PPP值较大，被选择的概率也就相对较大。但由于选择过程具有随机性，并不能保证每次选择均选中这些较优的染色体，因此较差染色体也有一定的生存空间。 交配算子 在染色体交配阶段,每个染色体能否进行交配由交配概率PcP_cPc​(一般取值为0.4 0.990.4~0.990.4 0.99之间)决定，其具体过程为：对于每个染色体，如果Random(0,1)Random(0,1)Random(0,1)小于PcP_cPc​则表示该染色体可进行交配操作，其中Random(0,1)Random(0,1)Random(0,1)为[0,1][0,1][0,1]间均匀分布的随机数产生器，否则染色体不参与交配直接复制到新种群中。 每两个按照PcP_cPc​交配概率选择出来的染色体进行交配，经过交换各自的部分基因，产生两个新的子代染色体。其具体操作是随机产生一个有效的交配位置，染色体交换位于该交配位置后的所有基因。参与交配的父代染色体个数与产生的子代染色体个数一样，因此新种群的规模依然为NNN。 变异算子 染色体的编译作用于基因之上，对于交配后新种群中染色体的每一位基因，根据变异概率PmP_mPm​判断该基因是否变异。如果Random(0,1)Random(0,1)Random(0,1)小于PmP_mPm​，则改变该基因的取值；否则该基因不发生变异，保持不变。 为了保持遗传算法较好的运行性能，变异概率PmP_mPm​应该设置在一个合适的范围内。变异操作通过改变原有染色体的基因，在提高群体多样性方面具有明显的促进作用。如果PmP_mPm​过小，算法容易早熟，在算法运行过程中，已找到的较优解可能在变异过程中遭到破坏；如果PmP_mPm​过大，可能会导致算法目前所处的较好的搜索状态倒退回到原来较差的情况。因此，应该讲种群的变异限制在一定范围内。一般地，PmP_mPm​可设定在0.001 0.1之间0.001~0.1之间0.001 0.1之间 算法流程 遗传算法的基本步骤： 初始化规模为NNN的群体，其中染色体每个基因的值采用随机数产生器生成。当前进化代数Generation=0Generation=0Generation=0 采用评价函数对群体中所有染色体进行评价，分别计算每个染色体的适应值，保存适应值最大的染色体BestBestBest 采用轮盘赌选择算法对群体中的染色体进行选择操作，产生规模同为NNN的种群。 按照概率PcP_cPc​从种群中选择染色体进行交配。每两个进行交配的父代染色体，交换部分基因，产生两个新的子代染色体，子代染色体取代父代染色体进入新种群。没有进行交配的染色体则直接复制进入新种群。 按照概率PmP_mPm​对新种群中染色体的基因进行变异操作。发生变异的基因数值发生改变。变异后的染色体取代原有染色体进入新群体，未发生变异的染色体直接进入新群体。 变异后的新群体取代原有群体，重新计算群体中各个染色体的适应值。倘若群体的最大适应值大于BestBestBest，则以该最大适应值对应的染色体替代BestBestBest 当前进化代数GenerationGenerationGeneration加111。如果GenerationGenerationGeneration超过规定的最大进化代数或BestBestBest达到规定的误差要求，算法结束；否则回到步骤333 注：染色体的交配和变异操作均是在选择后进行的。]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算智能——最优化问题]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最优化问题 最优化问题是在科学研究和生产实践中经常遇到的问题。人类所从事的一切生产或社会活动均是有目的的，其行为总是在特定的价值观念或审美取向的支配下进行的，因此经常面临求解一个可行的甚至是最优的方案的决策问题，这就是所谓的最优化问题（Optimization Problem） 最优化问题的求解模型: minf(X),X∈Dmin f(X), X \in D minf(X),X∈D 其中DDD是问题的解空间，XXX是DDD中的一个合法解。一般可将XXX表示为X=(x1,x2,...,xn)X=(x_1,x_2,...,x_n)X=(x1​,x2​,...,xn​)，表示一组决策变量。最优化问题就是在解空间中寻找一个合法的解XXX(一组最佳的决策变量)，使得XXX对应的函数值f(X)f(X)f(X)最小(最大)。 根据决策变量xix_ixi​的取值类型，可以将最优化问题分为函数最优化问题和组合最优化问题问题两大类。称决策变量均为连续变量的最优化问题为函数优化问题；若一个最优化问题的全部决策变量均为离散取值，则成为组合优化问题。现实应用问题中的数学模型多为混合型，即模型的部分决策变量为连续性，部分决策变量为离散型。 函数优化问题 函数优化问题对应的决策变量均为连续变量,优化问题fff的目标函数值取决于其对应的连续变量x1,x2,...xnx_1,x_2,...x_nx1​,x2​,...xn​的取值。在这种问题中，需要优化的变量的取值是某个连续区间上的值,是一个实数。各个决策变量之间可能是独立的，也可能是相互关联、相互制约的，它们的取值组合构成了问题的一个解。由于决策变量是连续值，因此对每个变量进行枚举是不可能的。在这种情况下，必须借助优化方法对问题进行求解。 组合优化问题 和函数优化问题不同，组合优化问题的决策变量是离散地，例如整数规划问题、0-1规划问题等。 典型的组合优化问题包括 **旅行商问题（TSP，Traveling Salesman Problem）**和 0-1背包问题（Zero//One Knapsack Problem，ZKP、0-1KP/KP） 这两种问题分别是一种基于排序的组合优化问题和一种基于二进制取值的组合优化问题，是组合优化问题的两种重要类型。 百度百科： 旅行商问题 0-1背包问题 维基百科： 旅行商问题 0-1背包问题 计算复杂性 一般而言，最优化都是“难解问题”。以旅行商问题和背包问题为例，虽然它们的定义非常简单易懂，但是寻求到最优解并不是一件容易的事情。直观的看，旅行商问题就是nnn个城市的一个排序问题，如果使用穷举法，需要进行(n−1)!(n-1)!(n−1)!次的枚举。背包问题是一个nnn位的二进制的0、10、10、1取值问题，000表示不选择，111表示选择，因此有2n2^n2n种可能。由此课件，仅当问题的规模nnn较小时，穷举法才是可能的。由于问题的解空间随着规模的增大呈指数级增长，因此需要寻求其他有效且高效的算法解决这类问题的大规模实例。 在计算机科学中，常用 计算复杂性 （Computational Complexity） 来描述问题的难易程度或者算法的执行效率。问题的计算复杂性是问题规模的函数。 对于旅行商问题和背包问题这种很难寻求到一种多项式复杂性的算法来进行求解的问题，习惯称为 NP难 （Non-deterministic Polynomial Hard，NPH）问题，或者NP完全（Non-deterministic Polynomial Complete，NPC）问题。 智能优化计算方法：计算智能算法 随着技术的进步，工程实践问题变得越来越复杂，传统的计算方法面临着计算复杂度高、计算实践长等问题，特别是对于一些NP难和NP完全问题，设计用于求解这些问题的精确算法由于其指数级的计算复杂性而令人无法接受。对于这些难解问题，传统的精确算法根本无法在可以忍受的时间内求出解。因此，为了在求解时间和求解精度上去的平衡，人们提出了形形色色具有启发式特征的计算方法，这些算法或模仿生物界的进化过程，或模仿生物的生理构造和身体机能，或模仿动物的群体行为，或模仿人类的思维、语言和记忆过程的特征，或模仿自然界的物理现象，希望通过模拟大自然和人类的智慧实现对问题的优化求解，在可接受的时间内求解得到可接受的解。这些算法就是只能优化算法，也叫 计算智能（Computational Intelligence，CI） 算法； 计算智能是借助自然界（生物界）规律的启示，根据其规模，设计出求解问题的算法。从关系上说，计算智能属于人工智能的一个分支。 计算智能的分类 计算智能方法在模拟人脑的联想、记忆、发散思维、非线性推理、模糊概念等传统人工智能难以胜任的方面表现优异。与传统的人工智能技术互相交叉、取长补短。 计算智能主要包含神经计算、模糊计算和进化计算三大部分。 计算智能的主要分类： {神经计算：人工神经网络算法模糊计算：模糊逻辑进化计算{遗传算法（进化策略、进化规划）蚁群优化算法粒子群优化算法免疫算法分布估计算法Memetic算法...单点搜索{模拟退火算法禁忌搜索算法...\begin{cases} 神经计算：人工神经网络算法\\\\ 模糊计算：模糊逻辑\\\\ 进化计算 \begin{cases} 遗传算法（进化策略、进化规划）\\ 蚁群优化算法\\ 粒子群优化算法\\ 免疫算法\\ 分布估计算法\\ Memetic算法\\ ... \end{cases}\\\\ 单点搜索\begin{cases} 模拟退火算法\\ 禁忌搜索算法\\ ... \end{cases} \end{cases} ⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​神经计算：人工神经网络算法模糊计算：模糊逻辑进化计算⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​遗传算法（进化策略、进化规划）蚁群优化算法粒子群优化算法免疫算法分布估计算法Memetic算法...​单点搜索⎩⎪⎨⎪⎧​模拟退火算法禁忌搜索算法...​​ 参考书目： 《计算智能》 张军、詹志辉编著 清华大学出版社 PS: 计算智能的内容是我在学习之后整理的，其中有书上的内容，也有自己的理解。 做这个工作的目的呢 一是做个记录，方便日后有遗忘或者疑问时查看。 二是贴在博客上，大家能共同学习共同进步，也能发现我的错误。 由于本人学识浅薄，整理的内容很可能会有纰漏，没有大牛那么厉害，勿喷 如果你发现了什么错误或者有什么新的见解欢迎和我交流讨论。 我的邮箱是 fanyousen98@163.com]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算智能</tag>
        <tag>最优化问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook的安装与使用]]></title>
    <url>%2F2019%2F06%2F02%2FGitBook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GitBook的安装 首先介绍一下gitbook gitbook是一个软件，使用markdown来编写，使用git来进行版本控制 GitBook支持输出多种文档格式,如: 静态站点:Git默认输出该格式,生成的静态站点可直接托管搭载GitHub Pages服务上 PDF:需要安装gitbook-pdf依赖 ebook:需要安装ebook-convert依赖 mobi格式 GitBook官网 GitBookEditor 有关教程: GitBook简明教程 GitBook命令行速览 GitBook教程 安装 node.js Node.js官网 下载安装文件后,安装即可,安装后将nodejs配置到环境变量中 配置完环境变量后,使用命令行检查下是否安装成功 $ node -v 配置正确的话,会输出版本号 安装GitBook 在完成上述步骤后,npm已经可以使用了 安装gitbook-cli $ npm install gitbook-cli -g 有的教程没有安装gitbook-cli这一步，gitbook-cli是一个gitbook的命令行工具,通过它可以在电脑上安装和gitbook的多个版本 所以不安装gitbook-cli直接安装gitbook也是可行的，gitbook-cli只是一个版本控制工具 安装GitBook $ npm install gitbook -g 安装后命令行执行gitbook -v 输出版本号即说明安装成功 gitbook-cli和gitbook是两个软件 gitbook-cli会将下载的gitbook的不同版本放到~/.gitbook文件夹中,可以通过设置GITBOOK_DIR环境变量来指定另外的文件夹 转换文档相关依赖的安装 安装Calibre 安装Calibre也是用来转换文档的，一开始没有安装，在网上搜了搜解决方法，发现是通过安装Calibre来解决的，因为通过此方法解决了问题，所以就暂且认为应该是这样解决的吧 Gitbook在转换文档的时候，需要使用一个叫ebook-convert 的驱动 安装Calibre后将Calibre配置到环境变量 Calibre官网地址 安装gitbook-pdf 命令行执行$ npm install gitbook-pdf -g 执行此命令时，当下载一个名为phantomjs的包时，会出现请求未响应的情况，这个时候，可以去phantomjs官网下载安装，安装方法如下：安装phantomjs 安装phantomjs PhantomJS下载地址 根据自己的系统下载对应的版本 PhantomJS是GitBook将markdown文件转pdf/epub等文件时用到的，没有安装PhantomJS转文档的时候会报错 值得注意的是，GitBook好像不支持高版本的PhantomJS，我一开始配置了phantomjs-2.1.1版本,转文档的时候,还是会报错，后来发现是需要低版本的phantomjs，遂去淘宝npm镜像下载了低版本的phantomj，我按照报错信息的要求下载配置了1.9.2版本 下载后解压然后配置到环境变量就OK了 GitBook的使用 gitbook项目结构： 12345678910.├── book.json├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md 各个文件的主要作用: book.json 存放配置信息 SUMMARY .md文件 概要文件主要存放GitBook的文件目录信息，目录就是根据此文件来自动生成的，默认对应的文件是SUMMARY.md,可以在book.json重新定义该文件的对应值.概要文件通过Markdown中列表语法来表示文件的父子关系: 12345678# Summary* [Introduction](README.md)* [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md)* [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 对应的目录结构如下所示: 通过使用标题或者水平分割线标志将GitBook分为几个不同的部分: 12345678910111213141516# Summary### Part I* [Introduction](README.md)* [Writing is nice](part1/writing.md)* [GitBook is nice](part1/gitbook.md)### Part II* [We love feedback](part2/feedback_please.md)* [Better tools for authors](part2/better_tools.md)----* [Last part without title](part3/title.md) 对应的目录结构如下所示: Glossary 词汇表文件 词汇表文件,默认对应的文件是GLOSSARY.md 该文件主要存储词汇信息,如果在其他页面中出现了该文件中的词汇,鼠标放在词汇上会给出词汇释意 GLOSSARY.md文件的格式如下: 12345## Git分散式版本控制软件## Markdown一种文本标记语言 GitBook的命令 列出gitbook所有的命令: gitbook help 输出gitbook-cli的帮助信息: gitbook --help 初始化gitbook: gitbook init 生成静态网页: gitbook build 生成静态网页并运行服务器: gitbook serve 生成时指定gitbook的版本,本地没有时会先下载安装: gitbook build --gitbook=2.0.1 列出本地所有的gitbook版本: gitbook ls 列出远程可用的gitbook版本: gitbook ls -remote 安装对应的版本: gitbook fetch 标签/版本号 更新到gitbook的最新版本: gitbook update 卸载对应的gitbook版本: gitbook uninstall 2.0.1 制定log的级别: gitbook build --log=debug 输出错误信息: gitbook build --debug GitBook配置文件 book.json title 标题 author 作者信息 description 书本描述 language 使用的语言 gitbook 制定gitbook版本 root 指定存放GitBook文件的根目录 links 在左侧边栏添加链接 styles 自定义样式 plugins 插件 pluginsConfig 插件配置 structure 设置README,SUMMARY,GLOSSARY等文件 title 设置书本标题 &quot;title&quot;:&quot;How to use gitbook&quot; author 作者的相关信息 &quot;author&quot; : &quot;fanyousen&quot; description 本书的简单描述 “description” : “本书描述” links 在左侧导航栏添加链接信息 12345&quot;links&quot;:&#123; &quot;sidebar&quot;:&#123; &quot;home&quot;:&quot;http://winslow.cn&quot; &#125;&#125; styles 自定义页面样式,默认情况下generator对应的css文件 1234567&quot;styles&quot;:&#123; &quot;website&quot;:&quot;styles/website.css&quot;, &quot;ebook&quot;:&quot;styles/ebook.css&quot;, &quot;pdf&quot;:&quot;styles/pdf.css&quot;, &quot;mobi&quot;:&quot;styles/mobi.css&quot;, &quot;epub&quot;:&quot;styles/epub.css&quot;&#125; 例如使&lt;h1&gt;&lt;h2&gt;标签下边框,可以在website.css中设置 123h1,h2&#123; border-bottom:1px solid #EFEAEA&#125; structure 指定README/SUMMARY/GLOSSARY和LANGUAGE对应的文件名,下面是默认值 变量 含义和默认值 structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.language Languages file name (defaults to LANGS.md) plugin 配置使用的插件 1234&quot;plugins&quot;:[ &apos;disqus&apos;, &quot;search&quot;] 添加插件后需要执行$ gitbook install来安装新的插件 Gitbook默认带有5个插件 highlight search sharing font-settings livereload 若要去除自带的插件,可以在插件名称前面加- 如去除search插件 123&quot;plugins&quot;:[ &quot;-search&quot;] pluginsConfig 配置插件的属性 1234567&quot;pluginsConfig:&quot;&#123; &quot;fontsettings&quot;:&#123; &quot;theme&quot;:&quot;sepia&quot;, &quot;family&quot;:&quot;serif&quot;, &quot;size&quot;:1 &#125;&#125; 插件 若要指定插件的版本可以使用: plugin@version 部分插件 Disqus - Disqus 评论 Search Plus - 支持中文搜索 Prsim - 使用 Prism.js 高亮代码 Advanced Emoji - 支持 emoji 表情 Github - 添加github图标 Github Buttons - 添加项目在 Github 上的 star、fork、watch 信息 Ace Plugin - 支持ace Emphasize - 为文字加上底色 KaTex - 支持数学公式 Include Codeblock - 用代码块显示包含文件的内容 Splitter - 使侧边栏的宽度可以自由调节 Mermaid-gb3 - 支持渲染 Mermaid 图表 Puml - 支持渲染 uml 图 Graph - 使用 function-plot 绘制数学函数图 Chart - 绘制图形 Sharing-plus - 分享当前页面 Tbfed-pagefooter - 为页面添加页脚 Expandable-chapters-small - 使左侧的章节目录可以折叠 Sectionx - 将页面分块显示 GA - Google 统计 3-ba - 百度统计 Donate - 打赏插件 Local Video - 使用 Video.js 播放本地视频 Simple-page-toc - 自动生成本页的目录结构 Anchors - 添加 Github 风格的锚点 Anchor-navigation-ex - 添加Toc到侧边悬浮导航以及回到顶部按钮 Edit Link - 链接到当前页源文件上 Sitemap-general - 生成sitemap Favicon - 更改网站的 favicon.ico Todo - 添加 Todo 功能 Terminal - 模拟终端样式 Copy-code-button - 为代码块添加复制按钮 Alerts - 添加不同 alerts 样式的 blockquotes Include-csv - 显示 csv 文件内容 Musicxml - 支持 musicxml 格式的乐谱渲染 Klipse - 集成 Kplise (online code evaluator) Versions-select - 添加版本选择的下拉菜单 Rss - 添加 rss 订阅功能``]]></content>
      <categories>
        <category>安装部署教程</category>
      </categories>
      <tags>
        <tag>GitBook</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Statement]]></title>
    <url>%2F2019%2F06%2F01%2FStatement%2F</url>
    <content type="text"><![CDATA[在这里说明一下： 由于本人正在准备考研，加上最近要期末考试，所以博文更新会不及时。 我是抽出空余时间一点一点写的，所以会出现博文不完整、只写了一部分的情况。 请不要嫌弃！！！ 一有时间我就会尽快更新。 谢谢！！]]></content>
  </entry>
</search>
