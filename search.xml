<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用数据校验方法]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 基本概念1.1. 数据校验数据校验百度百科 《圣经》中的《旧约》部分是犹太人记载的自创世纪以来，主要是摩西以来他们祖先的历史。《圣经》和中国《史记》这本由唯一作者写成的史书不同，《圣经》的写作持续了很多世纪，后世的人在做补充时，看到的是几百年前甚至是上千年前原作的抄本。抄写的错误便在所难免。据说今天也只有牛津大学保留了一本没有任何错误的古本。虽然做事认真的犹太人要求在抄写《圣经》时，要虔诚并且打起十二分精神，尤其是每写到“上帝”（God 和 Lord）这个词时要去洗手祈祷，不过抄写错误还是难以避免。于是犹太人发明了一种类似于我们今天计算机和通信中校验码的方法。他们把每一个希伯来字母对应于一个数字，这样每行文字加起来便得到一个特殊的数字，这个数字便成了这一行的校验码。同样对于每一列也是这样处理。当犹太学者抄完一页《圣经》时，他们需要把每一行的文字加起来，看看新的校验码是否和原文的相同，然后对每一页进行同样的处理。如果这一页每一行和每一列的校验码和原文完全相同，说明这一页的手抄无误。如果某行的校验码和原文中的对不上，则说明这一行至少有一个抄写错误。当然，错误对应列的校验码也一定和原文对不上，这样可以很快找到出错的地方。这背后的原理和我们今天的各种校验码时相同的。 上面是吴军《数学之美》一书中关于数据校验的一个例子，可见古代就已经有了对数据进行校验的方法。 在计算机和通信系统中，数据（二进制编码）在传输、存取过程中，会受到各种干扰的影响，使数据产生差错（如0变成1或1变成0）。为了能够发现及纠正传输过程中的差错，就在原始数据中增加冗余的编码，使其具有发现错误或纠错的功能。 2. 常见校验方式2.1. 奇偶校验奇偶校验(Parity Check)是一种非常简单的数据校验方法，使用非常广泛。 奇偶校验分为奇校验和偶校验 对于偶校验，如果一组给定数据位中1的个数是奇数，在校验位补一个bit为1使得1的总个数为偶数。若1的个数已经是偶数，则在校验位补一个bit为0例如：&emsp;&emsp;0000 001，1的个数为奇数，补一个bit为1，即 0000 0011&emsp;&emsp;0000 011，1的个数为偶数，补一个bit为0，即 0000 0110 对于奇校验，如果一组给定数据位中1的个数是偶数，在校验位补一个bit为1使得1的总个数为奇数。若1的个数已经是奇数，则在校验位补一个bit为0例如：&emsp;&emsp;0000 001，1的个数为奇数，补一个bit为0，即 0000 0010&emsp;&emsp;0000 011，1的个数为偶数，补一个bit为1，即 0000 0111 奇偶校验的错误检测： 如果传输过程中包括校验位在内的 奇数个数据位发生改变，那么数据的1的个数的奇偶性发生改变，从而可以发现数据出现错误（因为任何一个奇数或偶数加上一个奇数后，该数的奇偶性一定会发生改变）。因此，奇偶校验位是一种错误检测码，但是由于没有办法确定哪一位出错，所以它不能进行错误校正。发生错误时必须扔掉全部的数据，然后从头开始传输数据。 由上显然可以看出，当偶数个数据位发生改变时，使用奇偶校验方法并不能检测出数据出错。 2.2. 循环冗余校验CRC即循环冗余校验码，是数据通信领域中最常用的一种查错校验码，其特征是信息字段和检验字段的长度可以任意选定。循环冗余检查是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在数据的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。 2.2.1. CRC码的生成设CRC码共$n$位，信息字段$k$位生成多项式为$P(X)=X^3+X^2+1$，则除数$P=1101$，则余数位数为$r=3$信息为$D=1010 01$首先将$D$左移$n-k=r=3$位，得到$\acute{D} =1010 0100 0$再用$\acute{D}$除以$P$（使用模2除法）得到余数$R=001$则CRC码为$\acute{D} +R = 1010 0100 1$ CRC码的校验将接收到的CRC码除以除数$P$，得到余数$R$若$R=0$，则表示数据没有错误若$R=1$，则表示数据出错 2.3. 汉明码2.3.1. 汉明码的组成汉明码（也称为海明码）是由Richard Hanming于1950年提出的，它具有以为纠错能力。由编码纠错理论知，任何一种编码是否具有检测能力和纠错能力，都与编码的最小距离有关。编码最小距离，是指在一种编码系统中，任意两组合法代码之间的最少二进制位的差异。 1011101与1001001之间的汉明距离是22143896与2233796之间的汉明距离是3“toned”与”roses”之间的汉明距离是3汉明距离即码距 根据纠错理论得： L-1=D+C \quad 且D\geq C即编码最小距离$L$越大，则其检测错误得位数$D$越大，纠正错误的位数$C$也越大，且纠错能力恒小于或等于检错能力。例如当最小距离$L=3$时，这种编码可视为最多能检错二位，或能检错一位、纠错一位。可见，若能在信息编码中增加若干位检测位，增大$L$，显然能提高检错和纠错能力。汉明码就是根据这一理论提出的具有一位纠错能力的编码。 设预检测得二进制代码位$n$位，为使其具有纠错能力，需增添$k$位检测位，组成$n+k$位得代码。为了能准确对错误定位以及指出代码没错，新增添的检测位数$k$应满足： 2^k \geq n+k+1由此关系可求得不同代码长度$n$所需检测位的位数$k$，如下表所示： $n$ $k(最小)$ 1 2 2~4 3 5~11 4 12~36 5 … … $k$的位数确定后，便可由它们所承担的检测任务设定它们在被传送代码中的位置及它们的取值。设$n+k$位代码自左至右一次编号为$1,2,3,…,n+k$位，而将$k$位检测位记作$C_i(i=2,4,8,…)$，分别安插在$n+k$位代码编号的第$1,2,4,8,…,2^{k-1}$位上。这些检测位的设置是为了保证它们能分别承担$n+k$位信息中不同数位所组成的“小组”的奇偶校验任务，使检测位和它所负责检测的小组中$1$的个数位奇数或位偶数，具体分配如下： $C_1 检测的g_1小组包含1,3,5,7,9,11,…$位$C_2 检测的g_2小组包含2,3,6,7,10,11,14,15,…$位$C_4 检测的g_3小组包含4,5,6,7,12,13,14,15,…$位$C_8 检测的g_4小组包含8,9,10,11,12,13,14,15,24…$位… 将$C_1$的检测位$1,3,5,7,9,11,…$转换成二进制： 1 3 5 7 9 11 0001 0011 0101 0111 1001 1011 xxx1 xxx1 xxx1 xxx1 xxx1 xxx1 将$C_2$的检测位$2,3,6,7,10,11,14,15,…$转换成二进制： 2 3 6 7 10 11 14 15 0010 0011 0110 0111 1010 1011 1110 1111 xx1x xx1x xx1x xx1x xx1x xx1x xx1x xx1x 将$C_4$的检测位$4,5,6,7,12,13,14,15,…$转换成二进制： 4 5 6 7 12 13 14 15 ‭0100‬‬ ‭‭0101‬ ‭0110‬ ‭0111‬ ‭1100‬ ‭1101‬ ‭1110‬ ‭1111‬ ‭x1xx ‭‭x1xx ‭x1xx ‭x1xx‬ ‭x1xx ‭x1xx ‭x1xx ‭x1xx‬ 将$C_8$的检测位$8,9,10,11,12,13,14,15,24…$转换成二进制： 8 9 10 11 12 13 14 15 24 1000 ‭1001‬ ‭1010‬ 1011 ‭1100‬ ‭1101‬ ‭1110‬ ‭1111‬ ‭0001 1000‬ 1xxx ‭1xxx‬ ‭1xxx‬ 1xxx ‭1xxx ‭1xxx ‭1xxx ‭1xxx ‭xxxx 1xxx 由上四张表可以看出：第$g_i$组检测位的二进制代码中，从右往左数第$i$位都为1，即为每个检测小组所检测的检测位的规律 这种小组划分有如下特点： 每个小组$g_i$有一位且仅有一位为它独占，这一位是其他小组所没有的，即$g_i$小组独占第$2^{i-1}$位$i=1,2,3…$ 每两个小组$g_i$和$g_j$共同占有一位是其他小组没有的，即每两个小组$g_i$和$g_j$共同占有第$2^{i-1}+2^{j-1}$位$i,j=1,2,3…$ 每三个小组$g_i、g_j和g_l$共同占有第$2^{i-1}+2^{j-1}+2^{l-1}$位，是其他小组所没有的。 以此类推，便可确定每组所包含的各位 例如，欲传送信息为$b_4b_3b_2b_1(n=4)$，根据$2^k \geq n+k+1$，可求出配置汉明码需增添检测为$k=3$，且他们位置的安排如下： 二进制序号 1 2 3 4 5 6 7 名称 $C_1$ $C_2$ $b_4$ $C_4$ $b_3$ $b_2$ $b_1$ 若按照配偶原则来配置汉明码，则：$C_1$应使$1、3、5、7$位中的“1”的个数位偶数$C_2$应使$2、3、6、7$位中的“1”的个数位偶数$C_4$应使$4、5、6、7$位中的“1”的个数位偶数 令$b_4b_3b_2b_1=0101$，则$C_1=b_4 \bigoplus b_3 \bigoplus b1=0 \bigoplus 1 \bigoplus 1 = 0$$C_2=b_4 \bigoplus b_2 \bigoplus b1=0 \bigoplus 0 \bigoplus 1 = 1$$C_4=b_3 \bigoplus b_2 \bigoplus b1=1 \bigoplus 0 \bigoplus 1 = 0$ 故0101的汉明码应为$C_1C_2b_4C_4b_3b_2b_1$，即0100101 2.3.2. 汉明码的纠错过程哈明码的纠错过程实际上是对传送后的汉明码形成新的检测位$P_i(i=1,2,4,8…)$，根据$P_i$的状态，便可直接指出错误的位置。$P_i$的状态是由原检测位$C_i$及其所在小组“1”的个数确定的。倘若按配偶原则配置的汉明码，其传送后形成新的检测位$P_i$应为$0$，否则说明传送有错，并且还可直接指出出错的位置。由于$P_i$于$C_i$有对应关系，故$P_i$可由下式确定：$P_1=1 \bigoplus 3 \bigoplus 5 \bigoplus 7, 即 P_1 =C_1 \bigoplus b_4 \bigoplus b_3 \bigoplus b_1$$P_2=2 \bigoplus 3 \bigoplus 6 \bigoplus 7, 即 P_2 =C_2 \bigoplus b_4 \bigoplus b_2 \bigoplus b_1$$P_4=4 \bigoplus 5 \bigoplus 6 \bigoplus 7, 即 P_4 =C_4 \bigoplus b_3 \bigoplus b_2 \bigoplus b_1$ 设已知传送的正确汉明码（按配偶原则配置）为0100101，若传送后接收到的汉明码为0100111，其出错位可按下述步骤确定。令 二进制序号 1 2 3 4 5 6 7 正确的汉明码 0 1 0 0 1 0 1 接收到的汉明码 0 1 0 0 1 1 1 则新的检测位为： $P_4=4 \bigoplus 5 \bigoplus 6 \bigoplus 7, 即P_4=0 \bigoplus 1 \bigoplus 1 \bigoplus 1 = 1$$P_2=2 \bigoplus 3 \bigoplus 6 \bigoplus 7, 即P_2=1 \bigoplus 0 \bigoplus 1 \bigoplus 1 = 1$$P_1=1 \bigoplus 3 \bigoplus 5 \bigoplus 7, 即P_1=0 \bigoplus 0 \bigoplus 1 \bigoplus 1 = 0$ 由此可见，传送结果$P_4$和$P_2$均不是0，显然出了差错。分析发现，只有第6位出错才会同时使$P_4$和$P_2$为1。同时$P_4P_2P_1$所构成的二进制值恰好是出错的位置，即$P_4P_2P_1=110$，表示第6为出错。发现错误后，计算机便自动将错误的第6位“1”纠正位“0”。]]></content>
      <categories>
        <category>数据校验</category>
      </categories>
      <tags>
        <tag>数据校验</tag>
        <tag>奇偶校验</tag>
        <tag>循环冗余校验</tag>
        <tag>汉明码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吴军《数学之美》中的一段话，看了很有感触]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AE%B5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[最近在读《数学之美》这本书，看到了下面这段话，挺有感触： 每当福莱德和我谈起各自少年时的教育，我们都同意这样几个观点。首先，小学生和中学生其实没有必要花那么多时间读书，而他们的社会经验、生活能力以及在那时树立起的志向将帮助他们一生。第二，中学阶段花很多时间比同伴多读的课程，上大学以后用很短的时间就能读完，因为在大学阶段，人的理解能力要强的多。举个例子，在中学需要花500小时才能学会的内容，在大学可能化100小时就够了。因此，一个学生在中小学阶段建立的那一点点优势在大学很快就会丧失殆尽。第三，学习（和教育）是持续一辈子的过程，很多中学成绩优异的亚裔学生进入名校后表现明显不如那些出于兴趣而读书的美国同伴，因为前者持续学习的动力不足。第四，书本的内容可以早学，也可以晚学，但是错过了成长阶段却是无法补回来的。（因此，少年班的做法不足取。）现在中国的好学校里，恐怕百分之九十九的孩子在读书上花费的时间都比我当时要多，更比贾里尼克要多得多，但是这些孩子今天可能有百分之九十九在学术上的建树不如我，更不如贾里尼克。这实在是教育的误区。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>文摘</tag>
        <tag>数学之美</tag>
        <tag>吴军</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遗传算法简介及其实现]]></title>
    <url>%2F2019%2F06%2F04%2F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 遗传算法简介及其基本原理&emsp;&emsp;遗传算法（Genetic Algorithm，GA）是由美国密歇根大学心理学教授、电子工程学和计算机科学教授John H. Holland首先提出的一种随机自适应的全局搜索算法。遗传算法吸收了生命科学与工程学科中的重要理论成果，用于解决复杂优化问题。其中，达尔文的进化论和以孟德尔的遗传学说为基础的现代遗传学对算法的提出具有最为重要的影响。 &emsp;&emsp;生物的进化过程是一个不断往复的循环过程。在每个循环中，由于自然环境的恶劣、资源的短缺和天敌的侵害等因素，个体必须接受自然的选择。在选择过程中，一部分对自然环境具有较高适应能力的个体得以保存下来形成新的种群。而另一部分个体则由于不适应自然环境而面临被淘汰的危险。经过选择保存下来的群体构成种群，种群中的生物个体进行交配繁衍，保证了种群的发展。交配产生的子代继承了父代的部分特性，而且一般来说，子代要比父代具有更强的环境适应能力。进化过程伴随着种群的变异，种群中部分个体发生基因变异，成为新的个体。这样，经过选择、交配和变异后的种群取代了原来的种群，进入下一个循环。 &emsp;&emsp;遗传算法正是通过模拟自然界中生物的遗传进化过程，对优化问题的最优解进行搜索。算法维护一个代表问题潜在解得群体，对于群体的优化，算法引入了类似自然进化中选择、交配以及变异等算子。遗传算法搜索全局最优解的过程是一个不断迭代的过程（每一次迭代相当于生物进化中的一次循环），知道满足算法的终止条件为止。 &emsp;&emsp;在遗传算法中，问题的每个有效解被称为一个“染色体（chromosome）”，相对于群体中的每个生物个体（individual）。染色体的具体形式是一个使用特定编码方式生成的编码串。编码串中的每一个编码单元称为“基因（gene）”。 &emsp;&emsp;遗传算法通过比较适应值（fitness value）区分染色体的优劣，适应值越大的染色体越优秀。评估函数（evaluation function）用来计算并确定染色体对应的适应值。 &emsp;&emsp;选择算子（selection）按照一定的规则对群体的染色体进行选择，得到父代种群。一般地，越优秀的染色体被选中的次数越多。 &emsp;&emsp;交配算子（crossover）作用于每两个成功交配的染色体，染色体交换各自的部分基因，产生两个子代染色体。子代染色体取代父代染色体进入新种群，而没有交配的染色体则直接进入新种群。 &emsp;&emsp;变异算子（mutation）使新种群进行小概率的变异。染色体发生变异的基因改变数值，得到新的染色体。经过变异的新种群替代原有种群进入下一次进化。 定义表 生物遗传进化 遗传算法 群体 问题搜索空间的一组有效解（表现为群体规模$N$） 种群 经过选择产生的新群体（规模同样为$N$） 染色体 问题有效解的编码串 基因 染色体的一个编码单元 适应能力 染色体的适应值 交配 两个染色体交换部分基因得到两个新的子代染色体 变异 染色体某些基因的数值发生改变 进化结束 算法满足终止条件时结束，输出全局最优解 2. 遗传算法的流程遗传算法的实现主要包括了一下七个重要问题 染色体的编码 群体的初始化 适应值评价 选择种群 种群交配 种群变异 算法流程 &emsp;&emsp;这个几个问题尤其是选择算子、交配算子和变异算子的具体实现与算法搜索全局最优解的能力息息相关。在处理不同优化问题时，以上几个方面可能需要根据问题的特定情况采用不同的方法实现，以提高遗传算法的性能。 2.1. 染色体编码&emsp;&emsp;应用遗传算法，需要解决问题解的表示，即染色体的编码方式。染色体编码方式确定是否得当会对接下来染色体的交配和变异操作构成影响。在使用遗传算法解决具体问题时，采用何种编码方案不是一概而论的，应尽量分析问题的特点，制定可行的编码方案。 &emsp;&emsp;目前用于染色体编码的方法有格雷码编码、字母编码、多参数交叉编码等。下面仅介绍二进制编码方法（Binary Representation）和浮点数编码方法（Float Point Representation） 2.1.1. 二进制编码方式&emsp;&emsp;二进制编码方法产生的染色体是一个二进制符号序列，染色体的每一个基因只能取值$0$或$1$。假定问题定义的有效解空间为$[U_{min},U_{max}]^D$,其中$D$为有效解得变量维数，使用$L$位二进制符号串表示解的一维变量，则得到如下表所示的编码方式： 二进制符号串 对应的实际取值 $0000···0000$ $U_{min}$ $1111···1111$ $U_{max}$ $X_LX_{L-1}···X_2X_1$ $U_{min}+\frac{(U_{max}-U_{min}) \sum_{j=1}^{L} {X_j 2^{j-1}}}{2^L-1}$ &emsp;&emsp;例如，假设$[U_{min},U_{max}]为[1,64]$，采用$6$为二进制符号串进行编码，则某个二进制符号串$010101$代表了数值$22$ &emsp;&emsp;因此采用$L$位进行编码时的精度为$\frac{U_{max}-U_{min}}{2^L-1}$，可见该种方法在编码的精度方面是较差的。当要求采用较高的精度或表示较大范围的数时，必须通过增加$L$来达到要求。可是当$L$变得很大时，将增加算法操作复杂度和运算量。所以二进制编码在解决某些精度要求较高或解含有多个变量的优化问题时，表现得不尽人意。 2.1.2. 浮点数编码方式&emsp;&emsp;浮点数编码方法中，染色体的长度等于问题定义的解的变量个数，染色体的每一个基因等于解的每一维变量。例如待求解问题的一个有效解为$X_i=(x_{i}^{1},x_{i}^{2},···,x_{i}^{D-1},x_{i}^{D})$，其中D为解的变量维数。则该解对应的染色体编码为$(x_{i}^{1},x_{i}^{2},···,x_{i}^{D-1},x_{i}^{D})$。 &emsp;&emsp;浮点数编码方式适合于表示取值范围较大的数值，对降低采用遗传算法对染色体进行处理的复杂性起到了很好的作用。 2.2. 群体的初始化&emsp;&emsp;遗传算法在一个给定的初始化进化种群中进行迭代搜索。一般情况下，在群体初始化阶段采用的是随机数初始方法。采用生成随机数的方式，对染色体的每一维变量进行初始化赋值。如果在初始化时保证初始群体已经是一定程度上的优良群体的话，将能够有效提高算法找到全局最优解的能力。 2.3. 适应值评价&emsp;&emsp;评价函数用于评估各个染色体的适应值，进而区分优劣。评价函数常常根据问题的优化目标来确定，如在求解函数优化问题时，问题定义的目标函数可以作为评价函数的原型。对于求解最大值的问题，可以按照遗传算法的规定认为适应值越大染色体越优。对于其他优化问题，问题定义的目标函数必须经过一定的变换。例如，应用求解某个函数的最小值，可对问题定义的目标函数$f(X)$进行以下变换，得到算法的评价函数$Eval(C)$ Eval(C) = - f(X)其中$X$表示一个有效解，$C$表示$X$对应的染色体。 2.4. 选择算子&emsp;&emsp;种群的选择操作使用轮盘赌选择算法（roulette wheel selection）。轮盘赌选择算法是遗传算法中最经常使用的选择算法，其基本思想是基于概率的随机选择。&emsp;&emsp;轮盘赌选择算法首先根据群体中每个染色体的适应值得到群体所有染色体的适应值总和，并分别计算每个染色体适应值与群体适应值总和的比$P_i$；其次假设一个具有$N$个扇区的轮盘，每个扇区对应群体中的一个染色体，扇区的大小与对应染色体的$P_i$成正比关系。&emsp;&emsp;每次选择就转动一次轮盘，轮盘转动停止时指针停留的扇区对应的染色体即被选中进入种群。一次进行$N$次选择即可得到规模同样为$N$的种群。较优染色体的$P$值较大，被选择的概率也就相对较大。但由于选择过程具有随机性，并不能保证每次选择均选中这些较优的染色体，因此较差染色体也有一定的生存空间。 2.5. 交配算子&emsp;&emsp;在染色体交配阶段,每个染色体能否进行交配由交配概率$P_c$(一般取值为$0.4~0.99$之间)决定，其具体过程为：对于每个染色体，如果$Random(0,1)$小于$P_c$则表示该染色体可进行交配操作，其中$Random(0,1)$为$[0,1]$间均匀分布的随机数产生器，否则染色体不参与交配直接复制到新种群中。&emsp;&emsp;每两个按照$P_c$交配概率选择出来的染色体进行交配，经过交换各自的部分基因，产生两个新的子代染色体。其具体操作是随机产生一个有效的交配位置，染色体交换位于该交配位置后的所有基因。参与交配的父代染色体个数与产生的子代染色体个数一样，因此新种群的规模依然为$N$。 2.6. 变异算子&emsp;&emsp;染色体的编译作用于基因之上，对于交配后新种群中染色体的每一位基因，根据变异概率$P_m$判断该基因是否变异。如果$Random(0,1)$小于$P_m$，则改变该基因的取值；否则该基因不发生变异，保持不变。 &emsp;&emsp;为了保持遗传算法较好的运行性能，变异概率$P_m$应该设置在一个合适的范围内。变异操作通过改变原有染色体的基因，在提高群体多样性方面具有明显的促进作用。如果$P_m$过小，算法容易早熟，在算法运行过程中，已找到的较优解可能在变异过程中遭到破坏；如果$P_m$过大，可能会导致算法目前所处的较好的搜索状态倒退回到原来较差的情况。因此，应该讲种群的变异限制在一定范围内。一般地，$P_m$可设定在$0.001~0.1之间$ 2.7. 算法流程遗传算法的基本步骤： $1.$ 初始化规模为$N$的群体，其中染色体每个基因的值采用随机数产生器生成。当前进化代数$Generation=0$$2.$ 采用评价函数对群体中所有染色体进行评价，分别计算每个染色体的适应值，保存适应值最大的染色体$Best$$3.$ 采用轮盘赌选择算法对群体中的染色体进行选择操作，产生规模同为$N$的种群。$4.$ 按照概率$P_c$从种群中选择染色体进行交配。每两个进行交配的父代染色体，交换部分基因，产生两个新的子代染色体，子代染色体取代父代染色体进入新种群。没有进行交配的染色体则直接复制进入新种群。$5.$ 按照概率$P_m$对新种群中染色体的基因进行变异操作。发生变异的基因数值发生改变。变异后的染色体取代原有染色体进入新群体，未发生变异的染色体直接进入新群体。$6.$ 变异后的新群体取代原有群体，重新计算群体中各个染色体的适应值。倘若群体的最大适应值大于$Best$，则以该最大适应值对应的染色体替代$Best$$7.$ 当前进化代数$Generation$加$1$。如果$Generation$超过规定的最大进化代数或$Best$达到规定的误差要求，算法结束；否则回到步骤$3$ 注：染色体的交配和变异操作均是在选择后进行的。 3. 遗传算法的实现(Python)未完待续]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算智能——最优化问题]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 最优化问题&emsp;&emsp;最优化问题是在科学研究和生产实践中经常遇到的问题。人类所从事的一切生产或社会活动均是有目的的，其行为总是在特定的价值观念或审美取向的支配下进行的，因此经常面临求解一个可行的甚至是最优的方案的决策问题，这就是所谓的最优化问题（Optimization Problem） 最优化问题的求解模型: min f(X), X \in D其中$D$是问题的解空间，$X$是$D$中的一个合法解。一般可将$X$表示为$X=(x_1,x_2,…,x_n)$，表示一组决策变量。最优化问题就是在解空间中寻找一个合法的解$X$(一组最佳的决策变量)，使得$X$对应的函数值$f(X)$最小(最大)。 &emsp;&emsp;根据决策变量$x_i$的取值类型，可以将最优化问题分为函数最优化问题和组合最优化问题问题两大类。称决策变量均为连续变量的最优化问题为函数优化问题；若一个最优化问题的全部决策变量均为离散取值，则成为组合优化问题。现实应用问题中的数学模型多为混合型，即模型的部分决策变量为连续性，部分决策变量为离散型。 1.1. 函数优化问题&emsp;&emsp;函数优化问题对应的决策变量均为连续变量,优化问题$f$的目标函数值取决于其对应的连续变量$x_1,x_2,…x_n$的取值。在这种问题中，需要优化的变量的取值是某个连续区间上的值,是一个实数。各个决策变量之间可能是独立的，也可能是相互关联、相互制约的，它们的取值组合构成了问题的一个解。由于决策变量是连续值，因此对每个变量进行枚举是不可能的。在这种情况下，必须借助优化方法对问题进行求解。 1.2. 组合优化问题&emsp;&emsp;和函数优化问题不同，组合优化问题的决策变量是离散地，例如整数规划问题、0-1规划问题等。 &emsp;&emsp;典型的组合优化问题包括 旅行商问题（TSP，Traveling Salesman Problem）和 0-1背包问题（Zero//One Knapsack Problem，ZKP、0-1KP/KP） 这两种问题分别是一种基于排序的组合优化问题和一种基于二进制取值的组合优化问题，是组合优化问题的两种重要类型。 百度百科： 旅行商问题0-1背包问题 维基百科： 旅行商问题0-1背包问题 2. 计算复杂性&emsp;&emsp;一般而言，最优化都是“难解问题”。以旅行商问题和背包问题为例，虽然它们的定义非常简单易懂，但是寻求到最优解并不是一件容易的事情。直观的看，旅行商问题就是$n$个城市的一个排序问题，如果使用穷举法，需要进行$(n-1)!$次的枚举。背包问题是一个$n$位的二进制的$0、1$取值问题，$0$表示不选择，$1$表示选择，因此有$2^n$种可能。由此课件，仅当问题的规模$n$较小时，穷举法才是可能的。由于问题的解空间随着规模的增大呈指数级增长，因此需要寻求其他有效且高效的算法解决这类问题的大规模实例。 &emsp;&emsp;在计算机科学中，常用 计算复杂性 （Computational Complexity） 来描述问题的难易程度或者算法的执行效率。问题的计算复杂性是问题规模的函数。 &emsp;&emsp;对于旅行商问题和背包问题这种很难寻求到一种多项式复杂性的算法来进行求解的问题，习惯称为 NP难 （Non-deterministic Polynomial Hard，NPH）问题，或者NP完全（Non-deterministic Polynomial Complete，NPC）问题。 3. 智能优化计算方法：计算智能算法&emsp;&emsp;随着技术的进步，工程实践问题变得越来越复杂，传统的计算方法面临着计算复杂度高、计算实践长等问题，特别是对于一些NP难和NP完全问题，设计用于求解这些问题的精确算法由于其指数级的计算复杂性而令人无法接受。对于这些难解问题，传统的精确算法根本无法在可以忍受的时间内求出解。因此，为了在求解时间和求解精度上去的平衡，人们提出了形形色色具有启发式特征的计算方法，这些算法或模仿生物界的进化过程，或模仿生物的生理构造和身体机能，或模仿动物的群体行为，或模仿人类的思维、语言和记忆过程的特征，或模仿自然界的物理现象，希望通过模拟大自然和人类的智慧实现对问题的优化求解，在可接受的时间内求解得到可接受的解。这些算法就是只能优化算法，也叫 计算智能（Computational Intelligence，CI） 算法； &emsp;&emsp;计算智能是借助自然界（生物界）规律的启示，根据其规模，设计出求解问题的算法。从关系上说，计算智能属于人工智能的一个分支。 3.1. 计算智能的分类&emsp;&emsp;计算智能方法在模拟人脑的联想、记忆、发散思维、非线性推理、模糊概念等传统人工智能难以胜任的方面表现优异。与传统的人工智能技术互相交叉、取长补短。 &emsp;&emsp;计算智能主要包含神经计算、模糊计算和进化计算三大部分。 计算智能的主要分类： \begin{cases} 神经计算：人工神经网络算法\\\\ 模糊计算：模糊逻辑\\\\ 进化计算 \begin{cases} 遗传算法（进化策略、进化规划）\\ 蚁群优化算法\\ 粒子群优化算法\\ 免疫算法\\ 分布估计算法\\ Memetic算法\\ ... \end{cases}\\\\ 单点搜索\begin{cases} 模拟退火算法\\ 禁忌搜索算法\\ ... \end{cases} \end{cases}参考书目： &emsp;&emsp;《计算智能》&emsp;张军、詹志辉编著&emsp;清华大学出版社 PS: 计算智能的内容是我在学习之后整理的，其中有书上的内容，也有自己的理解。 做这个工作的目的呢一是做个记录，方便日后有遗忘或者疑问时查看。二是贴在博客上，大家能共同学习共同进步，也能发现我的错误。 由于本人学识浅薄，整理的内容很可能会有纰漏，没有大牛那么厉害，勿喷如果你发现了什么错误或者有什么新的见解欢迎和我交流讨论。 我的邮箱是 fanyousen98@163.com]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算智能</tag>
        <tag>最优化问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook的安装与使用]]></title>
    <url>%2F2019%2F06%2F02%2FGitBook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. GitBook的安装首先介绍一下gitbookgitbook是一个软件，使用markdown来编写，使用git来进行版本控制GitBook支持输出多种文档格式,如: 静态站点:Git默认输出该格式,生成的静态站点可直接托管搭载GitHub Pages服务上 PDF:需要安装gitbook-pdf依赖 ebook:需要安装ebook-convert依赖 mobi格式 GitBook官网 GitBookEditor 有关教程: GitBook简明教程 &nbsp;GitBook命令行速览&nbsp;GitBook教程 1.1. 安装 node.jsNode.js官网 下载安装文件后,安装即可,安装后将nodejs配置到环境变量中 配置完环境变量后,使用命令行检查下是否安装成功 $ node -v 配置正确的话,会输出版本号 1.2. 安装GitBook在完成上述步骤后,npm已经可以使用了 1.2.1. 安装gitbook-cli$ npm install gitbook-cli -g 有的教程没有安装gitbook-cli这一步，gitbook-cli是一个gitbook的命令行工具,通过它可以在电脑上安装和gitbook的多个版本 所以不安装gitbook-cli直接安装gitbook也是可行的，gitbook-cli只是一个版本控制工具 1.2.2. 安装GitBook$ npm install gitbook -g 安装后命令行执行gitbook -v 输出版本号即说明安装成功 gitbook-cli和gitbook是两个软件 gitbook-cli会将下载的gitbook的不同版本放到~/.gitbook文件夹中,可以通过设置GITBOOK_DIR环境变量来指定另外的文件夹 1.3. 转换文档相关依赖的安装1.3.1. 安装Calibre安装Calibre也是用来转换文档的，一开始没有安装，在网上搜了搜解决方法，发现是通过安装Calibre来解决的，因为通过此方法解决了问题，所以就暂且认为应该是这样解决的吧 Gitbook在转换文档的时候，需要使用一个叫ebook-convert 的驱动安装Calibre后将Calibre配置到环境变量 Calibre官网地址 1.3.2. 安装gitbook-pdf命令行执行$ npm install gitbook-pdf -g 执行此命令时，当下载一个名为phantomjs的包时，会出现请求未响应的情况，这个时候，可以去phantomjs官网下载安装，安装方法如下：安装phantomjs 1.3.3. 安装phantomjsPhantomJS下载地址 根据自己的系统下载对应的版本 PhantomJS是GitBook将markdown文件转pdf/epub等文件时用到的，没有安装PhantomJS转文档的时候会报错 值得注意的是，GitBook好像不支持高版本的PhantomJS，我一开始配置了phantomjs-2.1.1版本,转文档的时候,还是会报错，后来发现是需要低版本的phantomjs，遂去淘宝npm镜像下载了低版本的phantomj，我按照报错信息的要求下载配置了1.9.2版本 下载后解压然后配置到环境变量就OK了 2. GitBook的使用2.1. gitbook项目结构：12345678910.├── book.json├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md 各个文件的主要作用: 2.1.1. book.json存放配置信息 2.1.2. SUMMARY .md文件概要文件主要存放GitBook的文件目录信息，目录就是根据此文件来自动生成的，默认对应的文件是SUMMARY.md,可以在book.json重新定义该文件的对应值.概要文件通过Markdown中列表语法来表示文件的父子关系: 12345678# Summary* [Introduction](README.md)* [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md)* [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 对应的目录结构如下所示: 通过使用标题或者水平分割线标志将GitBook分为几个不同的部分: 12345678910111213141516# Summary### Part I* [Introduction](README.md)* [Writing is nice](part1/writing.md)* [GitBook is nice](part1/gitbook.md)### Part II* [We love feedback](part2/feedback_please.md)* [Better tools for authors](part2/better_tools.md)----* [Last part without title](part3/title.md) 对应的目录结构如下所示: 2.1.3. Glossary 词汇表文件词汇表文件,默认对应的文件是GLOSSARY.md 该文件主要存储词汇信息,如果在其他页面中出现了该文件中的词汇,鼠标放在词汇上会给出词汇释意 GLOSSARY.md文件的格式如下: 12345## Git分散式版本控制软件## Markdown一种文本标记语言 2.2. GitBook的命令列出gitbook所有的命令: gitbook help 输出gitbook-cli的帮助信息: gitbook --help 初始化gitbook: gitbook init 生成静态网页: gitbook build 生成静态网页并运行服务器: gitbook serve 生成时指定gitbook的版本,本地没有时会先下载安装: gitbook build --gitbook=2.0.1 列出本地所有的gitbook版本: gitbook ls 列出远程可用的gitbook版本: gitbook ls -remote 安装对应的版本: gitbook fetch 标签/版本号 更新到gitbook的最新版本: gitbook update 卸载对应的gitbook版本: gitbook uninstall 2.0.1 制定log的级别: gitbook build --log=debug 输出错误信息: gitbook build --debug 2.3. GitBook配置文件 book.json title 标题 author 作者信息 description 书本描述 language 使用的语言 gitbook 制定gitbook版本 root 指定存放GitBook文件的根目录 links 在左侧边栏添加链接 styles 自定义样式 plugins 插件 pluginsConfig 插件配置 structure 设置README,SUMMARY,GLOSSARY等文件 2.3.1. title设置书本标题 &quot;title&quot;:&quot;How to use gitbook&quot; 2.3.2. author作者的相关信息 &quot;author&quot; : &quot;fanyousen&quot; 2.3.3. description本书的简单描述 “description” : “本书描述” 2.3.4. links在左侧导航栏添加链接信息 12345&quot;links&quot;:&#123; &quot;sidebar&quot;:&#123; &quot;home&quot;:&quot;http://winslow.cn&quot; &#125;&#125; 2.3.5. styles自定义页面样式,默认情况下generator对应的css文件 1234567&quot;styles&quot;:&#123; &quot;website&quot;:&quot;styles/website.css&quot;, &quot;ebook&quot;:&quot;styles/ebook.css&quot;, &quot;pdf&quot;:&quot;styles/pdf.css&quot;, &quot;mobi&quot;:&quot;styles/mobi.css&quot;, &quot;epub&quot;:&quot;styles/epub.css&quot;&#125; 例如使&lt;h1&gt;&lt;h2&gt;标签下边框,可以在website.css中设置 123h1,h2&#123; border-bottom:1px solid #EFEAEA&#125; 2.3.6. structure指定README/SUMMARY/GLOSSARY和LANGUAGE对应的文件名,下面是默认值 变量 含义和默认值 structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.language Languages file name (defaults to LANGS.md) 2.3.7. plugin配置使用的插件 1234&quot;plugins&quot;:[ &apos;disqus&apos;, &quot;search&quot;] 添加插件后需要执行$ gitbook install来安装新的插件 Gitbook默认带有5个插件 highlight search sharing font-settings livereload 若要去除自带的插件,可以在插件名称前面加- 如去除search插件 123&quot;plugins&quot;:[ &quot;-search&quot;] 2.3.8. pluginsConfig配置插件的属性 1234567&quot;pluginsConfig:&quot;&#123; &quot;fontsettings&quot;:&#123; &quot;theme&quot;:&quot;sepia&quot;, &quot;family&quot;:&quot;serif&quot;, &quot;size&quot;:1 &#125;&#125; 3. 插件若要指定插件的版本可以使用: plugin@version 部分插件 Disqus - Disqus 评论 Search Plus - 支持中文搜索 Prsim - 使用 Prism.js 高亮代码 Advanced Emoji - 支持 emoji 表情 Github - 添加github图标 Github Buttons - 添加项目在 Github 上的 star、fork、watch 信息 Ace Plugin - 支持ace Emphasize - 为文字加上底色 KaTex - 支持数学公式 Include Codeblock - 用代码块显示包含文件的内容 Splitter - 使侧边栏的宽度可以自由调节 Mermaid-gb3 - 支持渲染 Mermaid 图表 Puml - 支持渲染 uml 图 Graph - 使用 function-plot 绘制数学函数图 Chart - 绘制图形 Sharing-plus - 分享当前页面 Tbfed-pagefooter - 为页面添加页脚 Expandable-chapters-small - 使左侧的章节目录可以折叠 Sectionx - 将页面分块显示 GA - Google 统计 3-ba - 百度统计 Donate - 打赏插件 Local Video - 使用 Video.js 播放本地视频 Simple-page-toc - 自动生成本页的目录结构 Anchors - 添加 Github 风格的锚点 Anchor-navigation-ex - 添加Toc到侧边悬浮导航以及回到顶部按钮 Edit Link - 链接到当前页源文件上 Sitemap-general - 生成sitemap Favicon - 更改网站的 favicon.ico Todo - 添加 Todo 功能 Terminal - 模拟终端样式 Copy-code-button - 为代码块添加复制按钮 Alerts - 添加不同 alerts 样式的 blockquotes Include-csv - 显示 csv 文件内容 Musicxml - 支持 musicxml 格式的乐谱渲染 Klipse - 集成 Kplise (online code evaluator) Versions-select - 添加版本选择的下拉菜单 Rss - 添加 rss 订阅功能``]]></content>
      <categories>
        <category>安装部署教程</category>
      </categories>
      <tags>
        <tag>GitBook</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Statement]]></title>
    <url>%2F2019%2F06%2F01%2FStatement%2F</url>
    <content type="text"><![CDATA[在这里说明一下：由于本人正在准备考研，加上最近要期末考试，所以博文更新会不及时。我是抽出空余时间一点一点写的，所以会出现博文不完整、只写了一部分的情况。请不要嫌弃！！！一有时间我就会尽快更新。谢谢！！]]></content>
  </entry>
</search>
